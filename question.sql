/*
Navicat MySQL Data Transfer

Source Server         : dh
Source Server Version : 50560
Source Host           : localhost:3306
Source Database       : test

Target Server Type    : MYSQL
Target Server Version : 50560
File Encoding         : 65001

Date: 2020-01-06 17:18:21
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `question`
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `content` longtext CHARACTER SET utf8,
  `label` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=141 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES ('2', 'VS工作目录', '属性-》调试-》工作目录', 'c++');
INSERT INTO `question` VALUES ('3', '不能使用默认构造函数', '类中有其它复杂的类成员，且该类成员没有默认的构造函数，此时无法调用这个类的默认的构造函数（默认的构造函数时已删除的函数） ', 'c++');
INSERT INTO `question` VALUES ('4', '数据库占位符的使用', 'query->prepare(\"select * from question where id=?\")；\nquery->addBindValue(0,3)\n', 'qt');
INSERT INTO `question` VALUES ('6', 'qt连接数据库', '#include \"qsqldatabase.h\"\n#include \"qsqlquery.h\"\n\nQSqlDatabase db;\nQSqlQuery *query;\ndb.setDatabaseName(mConf.find(\"data_base_name\")->second);\n            db.setHostName(\"localhost\");\n            db.setUserName(mConf.find(\"user_name\")->second);\n            db.setPassword(mConf.find(\"db_password\")->second);\n            if (db.open())\n            {\n                query = new QSqlQuery(db);\n                isDbOpen = true;\n            }\nquery->exec(\"select * from info\");\n', 'qt');
INSERT INTO `question` VALUES ('7', 'QMainWindow', 'QMainWindow主要在windows下使用 ', 'qt');
INSERT INTO `question` VALUES ('8', 'QWidget', 'QWidget常用基类。窗口类的基类 ', 'qt');
INSERT INTO `question` VALUES ('9', 'QPushButton ', 'QPushButton b; \n    b.setText(\"lll\");//给按钮设置内容 \n    //b.show(); \n    /*如果不指定父对象，对象和对象（窗口和窗口）是没有关系的 \n    1.setParent（父对象显示，子对象自动显示） \n    2.通过构造杉树传参*/ \n    b.setParent(&w); \n    b.move(100,100); \n    b.show(); \n    QPushButton b1(&w);//通过构造函数传参 \n    b1.setText(\"bcd\"); \nb1.show(); \nb1.setStyleSheet(\"background: rgb(0,255,0));设置按钮背景颜色', 'qt');
INSERT INTO `question` VALUES ('10', '信号与槽函数', '/*&b1 信号发出者，指针类型 \n     * &QPushButton::pressed  处理的信号， 发送者的类名::处理的信号 \n     * this 信号接收者，指针类型 \n     * &MyWidget::close      槽函数 信号处理函数   接受者的类名::槽函数名 \n     */ \nQT4槽函数必须有slots关键字来修饰 \nconnect(&b1,&QPushButton::pressed,this,&MyWidget::close); \n  \n/*自定义槽函数，普通函数的用法 \n     * Qt5: 任意的成员函数，普通全局函数，静态函数 \n     * 槽函数需要和信号一致（参数，返回值） \n     * 由于信号都是没有返回值，所以槽函数一定没有返回值 \n    */ \nvoid mySlot(); \nconnect(&b1,&QPushButton::released,this,&MyWidget::mySlot); \n/*信号必须有signals关键字来声明 \n     * 信号没有返回值，但可以有参数 \n     * 信号就是函数的声明，只需声明无需定义 \n     * 使用 emit mySignal(); \n     * 信号可以重载 \n     */ \nsignals: \n    void mySignal(); \nvoid mySignal(int,QString); ', 'qt');
INSERT INTO `question` VALUES ('11', 'QDebug qt打印输出', '和c++  cout的用法一样，用的时候qDebug()<<a<<str; ', 'qt');
INSERT INTO `question` VALUES ('12', '函数指针和函数多态', '函数指针  void (*p)(int)=fun; \n信号多态处理  void (SubWidget::*testWidget)(int,QString)=SubWidget::mySignal; ', 'c++');
INSERT INTO `question` VALUES ('13', 'qt lambda表达式 需要.pro文件添加c++11', 'CONFIG+=C++11 \nconnect(b3,&QPushButton::released, [b3,a,b]()//a,b为只读，加关键字后可以修改\n[b3,a,b]() mutable { b3->setText(\"~_~\"); });\n [=]()lambda表达式中等号表示把外部所有局部变量、类中所有成员以值传递方式传入或者可可以自己写需要传递的值\n[b3,a,b] [&]()引用方式传入 ', 'qt');
INSERT INTO `question` VALUES ('14', '坐标系统', '1)对于窗口坐标原点在屏幕左上角，对于按钮坐标原点在窗口白色区域左上角 \n2)子窗口原点为相对于父窗口', 'qt');
INSERT INTO `question` VALUES ('15', 'qt内存管理机制', '直接或间接继承于QObject的类，指定父对象后，子对象如果是动态分配控件的new，不需要手动释放delete,系统会自动释放', 'qt');
INSERT INTO `question` VALUES ('16', 'QMenuBar 菜单条', 'QMenuBar *mBar=menuBar(); \n//添加菜单选项 \nQMenu *pFile=mBar->addMenu(\"文件\"); \n//添加菜单动作 \nQAction *pAction=pFile->addAction(\"new\"); ', 'qt');
INSERT INTO `question` VALUES ('17', 'QToolBar 工具栏', 'QAction *pAction;\nQToolBar *toolBar=addToolBar(\"tool Bar\"); \n    //工具栏添加快捷键,使用前面的指针就可以 \ntoolBar->addAction(pAction); \nQPushButton *b=new QPushButton; \nb->setText(\"1_1\"); \ntoolBar->addWidget(b); ', 'qt');
INSERT INTO `question` VALUES ('18', 'QStatusBar 状态栏', 'QStatusBar *statBar=statusBar(); \nQLabel *label=new QLabel(this); \nlabel->setText(\"Normal text file\"); \nstatBar->addWidget(label);//从左向右添加 \nstatBar->addWidget(new QLabel(\"3\",this)); \nstatBar->addPermanentWidget(new QLabel(\"6\",this));//从右向左添加 ', 'qt');
INSERT INTO `question` VALUES ('19', '#include <QAxWidget> 找不到文件', '修改pro文件，添加 QT += axcontainer ', 'qt');
INSERT INTO `question` VALUES ('20', 'MySql 动态库放置路径libmySQL.dll', 'D:QT5.9.2mingw53_32in ', 'qt');
INSERT INTO `question` VALUES ('21', 'release模式下无法调试', '属性页-》c/c++ -> 常规-》调试信息格式：程序数据（/Zi）\n         连接器-》调试-》生成调试信息：优化以便于调试(/DEBUG)', 'qt');
INSERT INTO `question` VALUES ('22', 'qt快捷键', 'F4跳到对应的.cpp', 'qt');
INSERT INTO `question` VALUES ('23', '中心控件', 'QTextEdit *qte=new QTextEdit(this);文本编辑 \nsetCentralWidget(qte);设置中心控件 ', 'qt');
INSERT INTO `question` VALUES ('24', '浮动窗口', 'QDockWidget *dock=new QDockWidget(this);//浮动窗口 \naddDockWidget(Qt::RightDockWidgetArea,dock);//主窗口增加浮动窗口 \nQTextEdit *dockQte=new QTextEdit(this);//文本编辑窗口 \ndock->setWidget(dockQte);//浮动窗口增加文本编辑器 ', 'qt');
INSERT INTO `question` VALUES ('25', '模态对话框', ' QDialog dlg;\ndlg.exec();//阻塞对话框', 'qt');
INSERT INTO `question` VALUES ('26', '非模态对话框', 'QDialog dlg; \n//  dlg.show(); //显示对话框不阻塞,函数运行完变量删除，对话框一闪消失 ', 'qt');
INSERT INTO `question` VALUES ('27', 'QDialog 对话框', 'QDialog dlg; \ndlg.show(); //显示对话框不阻塞,函数运行完变量删除，对话框一闪消失 \ndlg.exec();//阻塞对话框\nQDialog *dlg=new QDialog(this); \ndlg->setAttribute(Qt::WA_DeleteOnClose);//文本框关闭后删除 \n                   dlg->show(); ', 'qt');
INSERT INTO `question` VALUES ('28', 'QMessageBox 消息对话框', 'QMessageBox::about(this,\"关于QT\",\"对话框测试\");//消息对话框 \n                int ret=QMessageBox::question(this,\"question\",\"Are you ok?\"); ', 'qt');
INSERT INTO `question` VALUES ('29', 'QFileDialog 文件对话框', ' QString path=QFileDialog::getOpenFileName( \n                            this, \n                            \"open\", \n                            \"../\", \n                            tr(\"source(*.cpp *.h);;Text(*.txt);;all(*.*)\")); ', 'qt');
INSERT INTO `question` VALUES ('30', '消息对话框中文乱码', 'QStringLiteral类用于解决qt中的乱码问题\nQStringLiteral(\"中文信息\"); \n\n窗口标题乱码\n\nsetWindowTitle(QString::fromUtf16(u\"管理工具\"));', 'qt');
INSERT INTO `question` VALUES ('31', 'vs运行qt 中文乱码问题', '1.  //在头文件前面加上下面几行代码 \n2.  #ifdef WIN32  \n3.  #pragma execution_character_set(\"utf-8\")  \n4.  #endif ', 'qt');
INSERT INTO `question` VALUES ('32', 'resizeEvent重写窗口大小改变事件', '.h文件中添加声明\npublic:\nvoid resizeEvent(QResizeEvent * event)\n.cpp文件中重写这个函数', 'qt');
INSERT INTO `question` VALUES ('35', 'QTabWidget 主窗口左侧功能栏', '需要功能菜单显示在左侧，且文字水平，需要重写QProxyStyle（见最下面）\n\n最后再 ui.tabWidget->tabBar()->setStyle(new CustomTabStyle);\n\n用法：ui.tabWidget->addTab(&docDisp, \"Main\");增加新的窗口docDisp 是一个QWidget类\n标签切换触发事件：connect(ui.tabWidget, &QTabWidget::currentChanged, this, &DocManagement::dealTabClick);\nclass CustomTabStyle : public QProxyStyle\n{\npublic:\n    QSize sizeFromContents(ContentsType type, const QStyleOption *option,\n        const QSize &size, const QWidget *widget) const;\n\n    void drawControl(ControlElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const;\n \n};\n\n\ncpp文件\n\n#include \"CustomTabStyle.h\"\n\n\n\nQSize CustomTabStyle::sizeFromContents(ContentsType type, const QStyleOption *option,\n    const QSize &size, const QWidget *widget) const\n{\n    QSize s = QProxyStyle::sizeFromContents(type, option, size, widget);\n    if (type == QStyle::CT_TabBarTab)\n    {\n        s.transpose();\n        s.rwidth() = 70;\n        s.rheight() = 30;\n    }\n    return s;\n}\n\nvoid CustomTabStyle::drawControl(ControlElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const\n{\n    if (element == CE_TabBarTabLabel) {\n        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {\n            QRect allRect = tab->rect;\n\n            if (tab->state & QStyle::State_Selected) {\n                painter->save();\n                painter->setPen(0x89cfff);\n                painter->setBrush(QBrush(0x89cfff));\n                painter->drawRect(allRect.adjusted(1, 3, -1, -6));\n                painter->restore();\n            }\n            QTextOption option;\n            option.setAlignment(Qt::AlignCenter);\n            if (tab->state & QStyle::State_Selected) {\n                painter->setPen(0xf8fcff);\n            }\n            else {\n                painter->setPen(0x5d5d5d);\n            }\n            painter->drawText(allRect, tab->text, option);\n            return;\n        }\n    }\n\n    if (element == CE_TabBarTab) {\n        QProxyStyle::drawControl(element, option, painter, widget);\n    }\n}\n\n', 'qt');
INSERT INTO `question` VALUES ('38', 'vs qt 修改左上角图标', '在项目目录中添加XXX.qrc，添加内容：\n<RCC>\n    <qresource>\n      	  <file>images/sync.ico</file>\n	  <file>images/search.ico</file>\n	  <file>images/new.ico</file>\n    </qresource>\n</RCC>\n新建文件夹image,并将myapp.ico文件放到文件夹中，多个图标，添加多个路径即可，项目上右键-》添加现有项-》选择XXX.qrc文件\n项目中添加代码\nQIcon icon;\nicon.addFile(\":/image/myapp.ico\");\nsetWindowIcon(icon);\n\n按钮可以在ui界面设置图标，选择资源方式添加，选择对应的qrc文件', 'qt');
INSERT INTO `question` VALUES ('39', 'MFC空项目创建', '新建项目-》Visual C++ ->MFC->MFC 应用程序-》下一步-》基于对话框-》完成', 'MFC\n');
INSERT INTO `question` VALUES ('40', 'MessageBox', 'HWND hWnd = ::FindWindow(NULL, _T(\"新建文本文档 (2).txt - 记事本\"));//获取了一个窗口\n\nMessageBox(_T(\"第一个对话框\"), _T(\"提示\"),  MB_YESNOCANCEL|MB_ICONERROR);; //（对话框显示内容，对话框标题，对话框按钮类型）\nMB_ICONERROR图标类型\n该函数返回值为ok,no等按钮的宏定义（IDOK）。\n\n\nF12转到定义', 'MFC');
INSERT INTO `question` VALUES ('41', '图标|资源|对话框', '工程上点右键-》添加-》新建项-》资源-》资源文件（.rc）\n资源视图中找到刚才创建的.rc文件->右键-》添加资源（包括位图资源，光标资源，图标资源，等等）-》Icon(导入)/Dialog(对话框)-》编译（一般使用id最小的图标，在Resource.h里查看）\n\n\n资源：图标，光标，对话框...', 'MFC');
INSERT INTO `question` VALUES ('42', 'coding', '进入项目：\n任务-》里程碑（创建里程碑）\n       任务列表（创建任务）\n代码-》浏览代码，管理分支\n项目设置-》退出项目', 'windows\n');
INSERT INTO `question` VALUES ('43', 'OpenCv模板匹配', '    Mat img = imread(\"../images/tmp.tif\",1);\n    Mat img1 = imread(\"../images/2019_10_17_9_8_3_426_Z.tif\", 1);\n    if (img.empty()| img1.empty())\n    {\n        cout << \"load image failed...\" << endl;\n    }\n\n    Mat result;\n    matchTemplate(img1, img, result,4);\n    normalize(result, result, 0, 1, CV_MINMAX);\n    Point minLoc, maxLoc;\n    double minVal,maxVal;\n    minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());\n    rectangle(img1, Rect(maxLoc.x, maxLoc.y, img.cols, img.rows), Scalar(0, 255, 255), 2, 8);\n    namedWindow(\"result\", CV_NORMAL);\n    imshow(\"result\", img1);\n    \n    waitKey(0);\n\n    TM_SQDIFF        = 0\n    TM_SQDIFF_NORMED = 1\n    TM_CCORR         = 2\n    TM_CCORR_NORMED  = 3\n    TM_CCOEFF        = 4\n    TM_CCOEFF_NORMED = 5', 'opencv');
INSERT INTO `question` VALUES ('44', 'QImage用法', 'cv::Mat mat(1024,800,CV_8UC1);\nuchar *pSrc=mat.data;\nQImage image(mat.cols,mat.rows,QImage::Format_Indexed8)\n//QImage::Format_Indexed8  显示灰度图像\n\nimage.setColorCount(256);\nfor(int i=0;i<256;i++)\n{\n   image.setColor(i,qRgb(i,i,i));\n}\nfor(int r=0;r<mat.rows;r++)\n{\n   uchar *pDst=image.scanLine(r)//行数据首地址\n   memcpy(pDst,pSrc,mat.cols);\n   pSrc+=mat.step;\n}\n', 'qt');
INSERT INTO `question` VALUES ('45', 'Edit Control', '对.rc文件中的Dialog ui界面给Edit Control控件添加变量，在*Dlg.h文件中将变量类型修改为CEditEx（自定义的一个类）,实现这个类，在类中对编辑框输入的内容进行定义\n\n//头文件\n#pragma once\n\n\n// CEditEx 对话框\nclass CEditEx : public CEdit\n{\n    DECLARE_DYNAMIC(CEditEx)\n\npublic:\n    CEditEx();\n    virtual ~CEditEx();\n\nprotected:\n    DECLARE_MESSAGE_MAP()\npublic:\n    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);\n    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);\n};\n\n//cpp文件\n\n// EditEx.cpp : 实现文件\n//\n#include \"stdafx.h\"\n#include \"EditEx.h\"\n\n// CEditEx\n\nIMPLEMENT_DYNAMIC(CEditEx, CEdit)\n\nCEditEx::CEditEx()\n{\n}\n\nCEditEx::~CEditEx()\n{\n    \n}\n//algstitchcheck项目中查看', 'MFC');
INSERT INTO `question` VALUES ('47', '编辑框背景颜色', '.rc文件中找到对话框，右键-》类向导-》消息-》WM_CTLCOLOR->添加处理程序-》编辑代码，cpp文件中函数里添加如下代码：\n\nHBRUSH CPropDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\n{\n    HBRUSH hbr = CBCGPDialog::OnCtlColor(pDC, pWnd, nCtlColor);\n\n    if (nCtlColor == CTLCOLOR_EDIT &&\n            (pWnd->GetDlgCtrlID() == IDC_EDIT1 || \n                pWnd->GetDlgCtrlID() == IDC_EDIT2))\n    {\n        pDC->SetTextColor(RGB(255, 255, 255));\n        pDC->SetBkColor(RGB(0, 120, 215));//文本背景\n        hbr = CreateSolidBrush(RGB(37, 37, 37));//编辑框背景\n    }\n        \n\n     \n    return hbr;\n}', 'MFC');
INSERT INTO `question` VALUES ('48', 'DialogBox', '设置字体-》窗口初始化-》显示。。。。。\n需要支持拖动文件，将Accept Files设置为true（添加消息判断if(WM_DROPFILES==uMsg){}）\n//消息=消息号码+附加数据\nBOOL CALLBACK MainProc\n(\n	HWND hwndDlg,//本对话框句柄,修改消息的标题，移动窗口\n	UINT uMsg,//消息句柄，消息号码\n	WPARAM wParam,//uMsg携带的数据\n	LPARAM lParam//第二个参数\n	)\n{\n	CString s;\n	s.Format(_T(\"uMsg=%d,wParam=%d,lParam=%d\"), uMsg, wParam, lParam);\n\n	OutputDebugString(s);//可以在输出窗口输出\n	if (WM_COMMAND == uMsg)//WM windows 开头的都是windows信号，附带的消息，wParam,lParam\n	{\n		if (LOWORD(wParam) == IDCANCEL)//取低字节数据\n		{\n			EndDialog(hwndDlg, IDCANCEL);\n		}\n		if (LOWORD(wParam) == IDOK)\n		{\n		            int nLeft = GetDlgItemInt(hwndDlg, IDC_EDIT1,NULL,TRUE);//最后一个参数bSigned 是否有符号的数据类型标识\n			int nMid = GetDlgItemInt(hwndDlg, IDC_EDIT2, NULL, TRUE);\n			int nResut = nLeft + nMid;\n			SetDlgItemInt(hwndDlg, IDC_EDIT3, nResut, TRUE);\n		}\n	}\n	//截获按钮的操作\n	return FALSE;//一般return false由系统处理后面的任务\n}\nDialogBox(NULL, (LPCWSTR)IDD_CAP2_DIALOG, NULL, MainProc);//HINSTANCE ,LPCWSTR, ,回调函数', 'MFC');
INSERT INTO `question` VALUES ('49', 'UItralSO制作启动盘', '文件-》打开-》选择ISO镜像文件\n启动-》写入硬盘镜像\n\n USB-HDD （ USB Hard Drives 的缩写，硬盘模式）： 硬盘仿真模式，启动后U盘的盘符是C。（注意：这个模式在安装系统时容易混淆U盘和硬盘的C分区）。\n\n        USB-HDD+：增强的USB-HDD模式，DOS启动后显示C盘，兼容性高于USB-HDD模式。但对仅支持USB-ZIP的电脑无法启动。\n\n        USB-HDD + v2：USB-HDD + v2兼容性高于USB-HDD+，有可能支持USB-ZIP的电脑，在dos下启动后U盘盘符仍然显示为C盘。支持隐藏启动分区，可以防病毒、防误删和误格式化等。\n\n        USB-ZIP + v2：比USB-ZIP +多了一个深度隐藏功能。\n\n        至于什么深度隐藏功能还是太高深，我们做启动盘选择USB-HDD或USB-HDD+就行了，一般我都会选择USB-HDD+。\n', 'windows');
INSERT INTO `question` VALUES ('50', 'MFC变量类型', 'HANDLE of Windows =>HWND\nHANDLE of Instance =>HINSTANCE\nHANDLE of Icon =>HICON\n结构体\nPOINT  SIZE  RECT\n简单类型变量\nBOOL （TRUE  FALSE）//WIN32模式下不支持c++语法\nUINT u=20; //usigned int \nWPARAM和UINT一样，只是主要用于消息的传入\nLPARAM和long一个意思\nDWORD   unsigned long\nLONG    long\nWORD    unsigned short\nSHORT   short\nINT     int \n\nint i=10;\nPINT p=&i;所有变量加P指的是指针\nPSTR str=\"asdf\";\nLPSTR ss=\"asdf\";加P和加LP意思一样 char *\nLCSTR  cs=\"asdf\"; const char *\nLPTSTR ?\n1. LPWCH 转成 CString\nLPWSTR   s;  \nCString   cs   =   s;   \n2. CString 转成 LPWCH\nCString   astring(\"ssss\");   \nLPWSTR   pointer;   \npointer=(LPWSTR)(LPCTSTR)astring; \n', 'MFC');
INSERT INTO `question` VALUES ('51', 'Windows快捷键', 'alt + 鼠标左键拖动 .exe文件，松开左键后创建快捷方式', 'windows');
INSERT INTO `question` VALUES ('52', 'static edit', 'static edit 不参与焦点跳转', 'MFC');
INSERT INTO `question` VALUES ('53', 'GetDlgItemText', 'LPWSTR s;\nGetDlgItemText(NULL, IDC_EDIT3, s, sizeof(s));//sizeof的作用是即使编辑框输入更多也不会溢出', 'MFC');
INSERT INTO `question` VALUES ('54', 'Qt自定义控件', 'class MLable : public QLabel{};\n定义自定义类，然后到窗口ui界面，在相应的控件上点击右键-》提升为-》提升的类名输入 MLabel-》添加-》提升', 'qt');
INSERT INTO `question` VALUES ('55', 'Qt事件', 'globalPos()屏幕坐标\npos()窗口坐标\n\n//设置鼠标追踪\nsetMouseTracking(true);\n\nprotected:\n    void mousePressEvent(QMouseEvent *ev);//虚函数\n    void mouseReleaseEvent(QMouseEvent *ev);\n    void mouseMoveEvent(QMouseEvent *ev);\n   //进入窗口区域\n    void enterEvent(QEvent *event);\n    //离开窗口区域\n    void leaveEvent(QEvent *event);\n    void closeEvent(QCloseEvent *e);\n   void keyPressEvent(QKeyEvent *event)\n {\n   if(event->key()==Qt::Key_A)\n   {\n       \n   }\n\n }\n    //计时器功能 \n     void MyWidget::timerEvent(QTimerEvent *event)\n    {\n      构造函数添加int timerId= （startTimer(1000);//以毫秒为单位，每隔一秒调用）  启动定时器\n        取消定时器 killTimer(timerId)\n     static int sec=0;\n     sec++;\n     ui->label->setText(QString(\"<center><h1>Time Out: %1</h1></center>\").arg(sec));\n    }\n时间接收和忽略：接收就是自己写函数处理程序，接收后就不会自动往下传递，除非主动调用父类的处理程序，忽略就是调用父类的处理程序，父类会继续发送信号等操作\nvoid MPushButton::mousePressEvent(QMouseEvent *e)\n{\n    if(e->button()==Qt::LeftButton)\n    {\n        qDebug()<<\"按键被按下\";\n        e->ignore();//事件被忽略，时间传递给父组件，而不是父类\n        //e->accept();//接收后时间不会继续往下传递\n    }\n    else\n    {\n\n        QPushButton::mousePressEvent(e);\n    }\n\n}', 'qt');
INSERT INTO `question` VALUES ('56', 'QString 格式化', '字符串格式化：\nQString str=QString(\"<center><h1>Mouse Press: (%1, %2)</h1></center>\").arg(100).arg(\"Tom\");\n<center><h1>Mouse Press: (%1, %2)</h1></center>为设置字符串显示样式（html语句），第一个参数%1，第二个参数%2\n\nQString转char *:\nQString  str;\nchar*  ch;\nQByteArray ba = str.toLatin1(); // must\nch=ba.data();\n\nQString转int\nQString str(\"100\");\nint tmp = str.toInt();\n\nint转QString\nQString::number();', 'qt');
INSERT INTO `question` VALUES ('59', 'Qt event函数', '如果传入事件已被识别并且处理，则需要返回true,否则返回false,如果返回值是true,那么Qt会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一个事件。\n在event()函数中调用accepe()或者ignore(）函数没有作用，不会影响事件的传播。\nQEvent转换为所需要的类型，例如: QTimerEvent *evn=static_cast<QTimerEvent *>(e);\nbool event(QEvent *e)\n{\n   //事件分发e->type();\n  switch(e->type())\n  {\n    case QEvent::Close:\n     closeEvent();\n    case QEvent::MouseMove:\n     mouseMoveEvent(e); \n  }\n   \n\n}', 'qt');
INSERT INTO `question` VALUES ('60', 'eventFilter 事件过滤器', '构造函数中添加 ui->label_2->installEvent(this);//this父对象，指定有那个父对象处理,给label_2控件添加了事件过滤。\n事件过滤器和被安装的组件必须在同一个线程内，否则事件过滤器无效，Qt事件的调用最终都会追溯到virtual bool QCoreApplication::notify(QObject *receiver,QEvent *event);，该函数会将event发送给receiver,也就是调用receiver->event(event),其返回值就是来自receiver的事件处理器。\nbool eventFilter(QObject *watched, QEvent *env)\n{\n  if(watched==ui->label_2)\n  {\n    QMouseEvent *e=static_cast<QMouseEvent *>(env);\n    if(e->type()==QEvent::MouseMove)\n    {\n      \n      ui->label_2->setText(QString(\"Mouse move:(%1,%2)\")).arg(1).arg(2);\n    }\n  }\n  else\n  {\n    return QWidget::eventFilter(watched,e);\n  }\n}', 'qt');
INSERT INTO `question` VALUES ('62', 'QBitMap', 'QBitMap继承于QPixMap,区别在于QPixMap主要画彩色图像，QBitMap只有黑白两种颜色。\nQPainter p(this);\np.drawPixmap(200,0,QBitmap(\"./Image/1.tif\"));\n', 'qt');
INSERT INTO `question` VALUES ('63', 'qt根目录', 'build-Image-Desktop_Qt_5_9_2_MinGW_32bit-Debug这个编译生成的程序根目录是qt程序的根目录./', 'qt');
INSERT INTO `question` VALUES ('64', 'QPixmap', '可以直接读取图片绘图\nQPainter p(this);\np.drawPixmap(0,0,QPixmap(\"./Image/1.tif\"));\n\n\nQPixmap pixmap;\npixmap.load(\"./Image/1.tif\");\npixmap.save(\"./Image/2.tif\");', 'qt');
INSERT INTO `question` VALUES ('65', '绘图设备', 'QPixmap:针对屏幕进行优化了，和平台相关。不能对图片进行修改\n\nQImage：和平台无关，可以对图片进行修改。修改像素点，在线程中绘图。\n\nQPicture：保存绘图的状态（二进制文件）。', 'qt');
INSERT INTO `question` VALUES ('66', 'paintEvent', 'void MainWindow::paintEvent(QPaintEvent *event)//重写绘图事件，如果给窗口绘图一定要在paintEvent实现\n{\n    QPainter p(this);\n    QPixmap pixmap;\n    pixmap.load(\"./Image/1.tif\");\n    p.drawPixmap(0,0,pixmap);\n\n\n}', 'qt');
INSERT INTO `question` VALUES ('67', 'QPainter', ' QPixmap  pixmap(400,300);\n QPainter p(&pixmap);//指定了绘图设备\n p.fillRect(0,0,400,300,QBrush(Qt::white));//填充白色背景\n p.drawPixmap(0,0,80,80,QPixmap(\"./Image/1.tif\"));', 'qt');
INSERT INTO `question` VALUES ('68', '算法动态库挂在到平台修改内容', '修改D:InspectionSystemRunInspectionSystemAlgConfigAlgSystemAlgSetSystemConfig.ini文件\n算法类型2名称=AOI共面度检测\n算法类型2动态库名=AlgAOICoplanCheck.dll\n算法类型2检测类型=0\n\n修改工程中 check.cpp文件CSetPROP::GetAlgorithmInfo方法中算法名称，与上述.ini文件中一致就可以。（此处名称用于界面显示，不改此处界面显示不会变）。\n\n配置文件中不要配置与BCG相关配置，否则不进入界面就会报错', 'work');
INSERT INTO `question` VALUES ('69', '获取当前时间', '1、获取带日期的时间，使用QDateTime类\nQDateTime current_date_time =QDateTime::currentDateTime();\nQString current_date =current_date_time.toString(\"yyyy.MM.dd hh:mm:ss.zzz ddd\");\ncurrent_date字符串结果为\"2016.05.20 12:17:01.445 周五\"，其中时间的显示格式可灵活配置，此处简单说明本实例中用到的部分：\nyyyy表示年；MM表示月；dd表示日； hh表示小时；mm表示分；ss表示秒；zzz表示毫秒；ddd表示周几\n详细配置格式内容较多，有需要的请自行查看Qt Assistant中关于函数QString QDateTime::toString ( const QString & format ) const的说明\n2、只需要时间，不需要日期，也可使用QTime类\nQTime current_time =QTime::currentTime();\nint hour = current_time.hour();//当前的小时\nint minute = current_time.minute();//当前的分\nint second = current_time.second();//当前的秒\nint msec = current_time.msec();//当前的毫秒\n当然QTime也可以像QDateTime::toString那样直接输出固定格式的字符串，使用方法与QDateTime::toString类似，也可参考Qt Assistant中关于函数QString QTime::toString ( const QString & format ) const的说明\n', 'qt');
INSERT INTO `question` VALUES ('70', '获取当前时间', '1）使用strftime()进行格式转换\ntime_t t = time( 0 );\nchar tmp[64];\nstrftime( tmp, sizeof(tmp), \"%Y/%m/%d %X %A 本年第%j天 %z\",localtime(&t) );\nprintf(\"%s\n\",tmp);\n输出为“2016/05/20 13:11:57 Friday 本年第141天 中国标准时间”\n其中函数size_t strftime(char *strDest,size_t maxsize,const char *format,const  struct tm *timeptr)功能为根据format指向字符串中格式命令把timeptr中保存的时间信息放在strDest指向的字符串中，最多向strDest中存放maxsize个字符。该函数返回向strDest指向的字符串中放置的字符数。\nformat说明：\n%a 星期几的简写\n%A 星期几的全称\n%b 月份的简写\n%B 月份的全称\n%c 标准的日期的时间串\n%C 年份的前两位数字\n%d 十进制表示的每月的第几天\n%D 月/天/年\n%e 在两字符域中，十进制表示的每月的第几天\n%F 年-月-日\n%g 年份的后两位数字，使用基于周的年\n%G 年份，使用基于周的年\n%h 简写的月份名\n%H 24小时制的小时\n%I 12小时制的小时\n%j 十进制表示的每年的第几天\n%m 十进制表示的月份\n%M 十时制表示的分钟数\n%n 新行符\n%p 本地的AM或PM的等价显示\n%r 12小时的时间\n%R 显示小时和分钟：hh:mm\n%S 十进制的秒数\n%t 水平制表符\n%T 显示时分秒：hh:mm:ss\n%u 每周的第几天，星期一为第一天 （值从1到7，星期一为1）\n%U 第年的第几周，把星期日作为第一天（值从0到53）\n%V 每年的第几周，使用基于周的年\n%w 十进制表示的星期几（值从0到6，星期天为0）\n%W 每年的第几周，把星期一做为第一天（值从0到53）\n%x 标准的日期串\n%X 标准的时间串\n%y 不带世纪的十进制年份（值从0到99）\n%Y 带世纪部分的十制年份\n%z，%Z 时区名称，如果不能得到时区名称则返回空字符。\n%% 百分号\n（2）使用asctime()进行格式转换\n/*得到系统时间*/\ntime_t   cur;\nstruct tm          daytime;\ncur = time((time_t*)NULL);\ntime(&cur);       \n/*时间转换*/\ndaytime = *localtime(&cur);     \nprintf(\"%s\",  asctime(&daytime));\n输出为“Wed Feb 13 15:46:11 2016”\n', 'c++');
INSERT INTO `question` VALUES ('71', '使用windows API获取当前时间', '使用Windows API 函数GetLocalTime(精确到毫秒)\nSYSTEMTIME sys;\nGetLocalTime( &sys );\nprintf(\"%4d/%2d/%2d %2d:%2d:%2d.%3d\n\",  \nsys.wYear,sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds); \n输出为“2016/5/16 10:13:23.234”\n其中SYSTEMTIME结构体定义如下\ntypedef struct _SYSTEMTIME\n{\nWORD wYear;//年\nWORD wMonth;//月\nWORD wDayOfWeek;//星期，0为星期日，1为星期一，2为星期二……\nWORD wDay;//日\nWORD wHour;//时\nWORD wMinute;//分\nWORD wSecond;//秒\nWORD wMilliseconds;//毫秒\n}SYSTEMTIME,*PSYSTEMTIME;\n', 'c++');
INSERT INTO `question` VALUES ('72', 'QLineEdit ', 'QIntValidator v( 0, 100, this );    \n QLineEdit* edit = new QLineEdit( this );     // 这个行编辑只接受从0到100的整数     \nedit->setValidator( &v );', 'qt');
INSERT INTO `question` VALUES ('73', 'Qt样式表', 'QWidget::setStyleSheet()设计样式表\nui->label->setStyleSheet(\"QLabel{color:red;}\");\nui->label->setStyleSheet(\"QLabel{color:rgb(0,255,255);\"//字体\n                             \"background-color:black\"//背景\n                             \"}\");\nthis->setStyleSheet(\"QLabel{color:red;}\");//this内所有QLabel都是红色字体，但是可以具体QLabel更改\n\"background-image:url(:/new/prefix1/start.jpg)\"添加背景图，图像会平铺，不会自动缩放大小\n\"border-image:url(:/new/prefix1/start.jpg)\"       添加背景图，图像不会平铺，自动缩放大小\nQPushButton:hover{border: 2px outset green}  伪状态：(:hover)\nline-height : 150%  行高\nfont-size : 8pt;    字体大小\nfont-family:SimHei; 字体类型\nfont-weight: bold;  加粗\ncolor:blue;         字体颜色', 'qt');
INSERT INTO `question` VALUES ('74', '查看已连接无线网密码', '右键无线网图标-》网络和共享中心-》查看网络活动里单击无线网文字-》无线属性-》安全-》显示字符', 'windows');
INSERT INTO `question` VALUES ('75', '目标跟踪与定位1', 'Haris-Shi-Tomasi角点检测器（哈尔角点检测）\ncv::GFTTDetector::public cv::Featrue2D。\n参数（int maxCorners(检测的最大角点数量),\n      double qualityLevel (认定为是一个角点的最小低阶特征值，一般设置为0.1或0.01),\n      double minDistance(默认为1),\n      int blockSize(计算导数的自相关矩阵时对应像素所在区域，默认为3),\n      bool useHarrisDetector(是否用哈儿检测),\n      double k(权重系数，默认0.04) ）', 'opencv');
INSERT INTO `question` VALUES ('76', 'Python、Pip和Spyder的安装', '下载地址：https://www.python.org/downloads/\nPip的安装：\n1.下载：https://pypi.org/project/pip/#files\n2.在文件目录下，输入：python setup.py install ，安装pip安装完成后在Scripts目录下。环境变量配置pip\n\nUbuntu\nsudo apt install python-pip3(测试) python3-dev\n更新pip sudo pip3 install -U pip \n\nSpyder:  pip install spyder\n\n', 'Python');
INSERT INTO `question` VALUES ('77', 'Windows+Ubuntu双系统设置Windows为第一启动项', '在安装双系统的时候，如果先安装的是Windows然后再安装Ubuntu系统，开机时是以Ubuntu的grub来引导Windows的，而且默认进入Ubuntu系统。\n\n修改grub\n输入命令：sudo vim /etc/default/grub\n现在进入grub文件中，找到GRUB_DEFAULT=0，为0表示Ubuntu为第一个启动。现在主要是修改这个值来使Windows为第一启动项。\n在开机时会有选项让你选择进入哪个系统，默认是Ubuntu，则GRUB_DEFAULT=0，若第三个为Windows，则GRUB_DEFAULT=2。所以更改grub文件中的GRUB_DEFAULT的值，即可设置Windows为第一启动项。\n输入命令：sudo update-grub更新grub文件即可。\n\n首先打开grub的配置文件。sudo  gedit    /boot/grub/grub.cfg\n在配置文件中找到我们的win7引导菜单选项。\n复制win7引导菜单名称，例如这里的 Windows7 (loader) (on /dev/sdb1)。\n接着编辑etc下的grub文件。sudo  gedit   /etc/default/grub把里面的GRUB_DEFAULT设置为我们复制的win7引导菜单名称。\n接着我们更新grub菜单。sudo update-grub\n接着重启ubuntu系统，开机的时候就会默认选择win7系统进入。', 'Ubuntu');
INSERT INTO `question` VALUES ('78', '有线网络连接', '设置-》network里设置网络ip 网关等。\n\nsudo nano /etc/network/interfaces', 'Ubuntu');
INSERT INTO `question` VALUES ('79', '查看安装路径', 'which python3', 'Ubuntu');
INSERT INTO `question` VALUES ('80', '更换阿里源', 'sudo gedit /etc/apt/sources.list\n\n# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties\ndeb http://archive.canonical.com/ubuntu xenial partner\ndeb-src http://archive.canonical.com/ubuntu xenial partner\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n\nsudo apt-get update', 'Ubuntu');
INSERT INTO `question` VALUES ('81', 'dpkg 安装查看deb文件', '安装：sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb\n查看软件版本：pkg-config --modversion opencv\n查看安装包的安装路径：dpkg -L libhdf5-serial-dev\n\n$ pkg-config --cflags opencv\n输出的是编译时需要的头文件路径：-I /usr/local/opencv/include/opencv -I /usr/local/opencv/include\n\n$pkg-config --libs opencv\n输出的是编译时需要的链接库：/usr/local/opencv/lib/libopencv_calib3d.so /usr/local/opencv/lib/libopencv_core.so\n', 'Ubuntu');
INSERT INTO `question` VALUES ('82', '查看软件版本', 'pkg-config --modversion opencv', 'Ubuntu');
INSERT INTO `question` VALUES ('83', '搜狗输入法安装', '先安装搜狗输入法软件sudo dpkg -i install sogou*.deb\n打开终端运行命令：im-config后，点击OK，看到fcitx的窗口选择fcitx其余全部yes或者ok. 然后重启ubuntu。\nim-config找不到fcitx；\nsudo apt-get --fix-broken install 运行这条命令需要联网，可以考虑先更新阿里源\n在fcitxconfigure点击加号添加搜狗输入法。', 'Ubuntu');
INSERT INTO `question` VALUES ('84', '文件解压', 'Tar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。\n压缩 ： # tar -cvf archive_name.tar directory_to_compress\n解压缩：\ntar.bz2文件 tar jxvf boost_1_56_0.tar.bz2\ntar -jxvf xx.tar.bz2 -C /xx/xxx/xxx   -C大写，后面接要解压的路径\n\nunzip *.zip', 'Ubuntu');
INSERT INTO `question` VALUES ('85', 'nvidia 驱动、cuda和cudnn的安装', '运行nvidia_driver.sh cuda.sh 两个脚本\n先解压cudnn-9.0-linux-x64-v7.1.tgz\n再运行cudnn.sh，此处只是文件的复制。\nnvidia-smi   \nnvidia-settings \nubuntu-drivers devices 检查硬件信息\nubuntu-drivers autoinstall 自动安装驱动\n\nwindows驱动下载地址\nhttps://www.nvidia.cn/Download/index.aspx?lang=cn\n\ncuda toolkit历史版本\nhttps://developer.nvidia.com/cuda-toolkit-archive\n\ncudnn 历史版本\nhttps://developer.nvidia.com/cudnn', 'Ubuntu');
INSERT INTO `question` VALUES ('86', '查看cpu进程数量', 'top命令', 'Ubuntu');
INSERT INTO `question` VALUES ('87', 'Anaconda 安装', 'Ubuntu:\n到国内清华镜像https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/ \n所有安装包地址：https://repo.continuum.io/archive/\nbash Anaconda3-5.0.0-Linux-x86_64.sh\n如果后面你发现输出conda提示没有该命令，那么你需要source ~/.bashrc 这样就是更新环境变量，就可以正常使用了。\n如果发现这样还是没用，那么需要手动添加环境变量 \nexport PATH=/home/dl/anaconda3/bin:$PATH\nanaconda -v查看版本信息\n\n或者官网 https://repo.continuum.io/archive/', 'Python');
INSERT INTO `question` VALUES ('88', 'python版本', '# 第2种方法\nimport sys \nprint(sys.version)\nprint(sys.version_info)', 'Python');
INSERT INTO `question` VALUES ('89', 'anaconda更改下载源', '命令行中运行以下代码即可添加 Anaconda Python 免费仓库：\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --set show_channel_urls yes\n执行完上述命令后会在当前用户目录下生成.condarc文件\n确认.condarc文件内容 （在用户目录下，比如C:Users用户名.condarc）\nchannels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  \n  - defaults\nshow_channel_urls: true\n确认无误后，关闭控制台窗口，重新打开才会重新加载配置。（不确定是否正确，感觉不需要重新打开控制台窗口也可以）\n大部分网站上的说法都是如上。不过我做完如上更改，更新spyder的时候依旧使用的是官网的源，最后更新失败。\n最后发现把.condarc文件中的 - defaults那行去掉，就不会出现这个问题了。理论上直接建立.condarc文件，修改里面的内容，也可以实现同样的功能。我最终把其他的目录也加上了，最终的.condarc文件如下所示：\nchannels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  \n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mro\nshow_channel_urls: true\nconda info查看', 'Python');
INSERT INTO `question` VALUES ('90', 'anaconda查找安装包版本并指定channel安装', '查看安装包的所有可用版本和channel\nanaconda search -t conda skimage \n根据包名查找安装包channel\nanaconda show  DavidMertz/accelerate-skimage\n根据提示，我们使用下面的指令install这个包\nconda install --channel https://conda.anaconda.org/DavidMertz accelerate-skimage', 'Python');
INSERT INTO `question` VALUES ('91', 'spyder快捷键设置', 'Tools->Preferences->Keyboard shortcuts', 'Python');
INSERT INTO `question` VALUES ('92', 'spyder启动程序传入参数', 'Run ->Configure->  command line options', 'Python');
INSERT INTO `question` VALUES ('93', '安装包下载地址', 'https://www.lfd.uci.edu/~gohlke/pythonlibs/', 'Python');
INSERT INTO `question` VALUES ('94', 'Anaconda创建python环境', 'conda create -n python27 python = 2.7\n\nubuntu:\nsource activate python27\nsource deactivate python27\nwindows:\nactivate python27\ndeactivate python27', 'Python');
INSERT INTO `question` VALUES ('95', 'TensorRt安装', 'https://blog.csdn.net/macwinwin/article/details/80177326\nsudo apt install --no-install-recommends libboost-all-dev\n\nsudo gedit ~/.bashrc \n\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/nvidia/TensorRT-5.0.2.6/lib\n', 'Ubuntu');
INSERT INTO `question` VALUES ('97', '查看安装路径', 'which python3', 'Ubuntu');
INSERT INTO `question` VALUES ('98', 'g++/gcc用法', 'g++ -o test test.cpp -I/usr/local/include -I/usr/local/include/opencv -I/usr/local/include/opencv2 -L /usr/local/lib -lopencv_core -lopencv_highgui -lopencv_imgproc -lopencv_legacy -lopencv_ml -lpthread\n\n参数解释:\n\n    gcc -i 参数说明:包含头文件 -include和-I参数  \n\n    gcc -l 参数说明: libopencv_core330  完整dll文件名,上面args载入的就是D:/opencv/build/x64/mingw/lib/libopencv_core330.dll.a\n \n', 'Ubuntu');
INSERT INTO `question` VALUES ('99', 'Ubuntu环境变量', '必须把编译生成的opencv的.a或者.so静态库和动态库的路径，比如[/home/opencv/lib]，\n配置bash，执行如下命令\n\nsudo gedit /etc/bash.bashrc  \n\n在末尾添加\n\n    PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig  \n      \n    export PKG_CONFIG_PATH  \n\n保存退出，然后执行如下命令使得配置生效\n\nsource /etc/bash.bashrc  \n\n首先将OpenCV的库添加到路径，从而可以让系统找到\n\nsudo gedit /etc/ld.so.conf.d/opencv.conf \n\n执行此命令后打开的可能是一个空白的文件，不用管，只需要在文件末尾添加\n\n/usr/local/lib  \n\n然后保存退出，执行如下命令使得刚才的配置路径生效\n\nsudo ldconfig  \n\n在了解/etc/ld.so.conf.d/目录下文件的作用之前，先介绍下程序运行是加载动态库的几种方法：\n第一种，通过ldconfig命令\n    ldconfig命令的用途, 主要是在默认搜寻目录(/lib和/usr/lib)以及动态库配置文件/etc/ld.so.conf内所列的目录下, 搜索出可共享的动态链接库(格式如lib*.so*), 进而创建出动态装入程序(ld.so)所需的连接和缓存文件. 缓存文件默认为/etc/ld.so.cache, 此文件保存已排好序的动态链接库名字列表.\n    这里面涉及到的关键内容有命令：ldconfig，配置文件目录：/etc/ld.so.conf.d，配置文件在/etc/ld.so.conf内容由用户编辑，缓冲文件/etc/ld.so.cache。下面举个例子，比如你在部署软件时，有些动态库安装在exe目录下，可以通过如下方法实现，\n1）配置exe.conf文件，里面加一行～/exe，然后将该文件放到/etc/ld.so.conf.d目录下；\n2）在/etc/ld.so.conf文件中增加一行include ld.so.conf.d/exe.conf\n3）执行 ldconfig命令\n之后程序运行时，会自动增加在exe目录中搜索动态库。\n\n第二种，通过LD_LIBRARY_PATH环境变量\n可以通过在.bashrc或者.cshrc中配置该环境变量，LD_LIBRARY_PATH的意思是告诉loader在哪些目录中可以找到共享库. 可以设置多个搜索目录, 这些目录之间用冒号分隔开.\n同样是上面的例子，可以通过以上的方法来实现\n在.bashrc或.cshrc中增加一行，export LD_LIBRARY_PATH = ～/exe：$LD_LIBRARY_PATH即可。\n\n第三种，通过编译选项-Wl， -rpath指定动态搜索的路径\n    -Wl选项告诉编译器将后面的参数传递给链接器。\n    通过上面的介绍，对/etc/ld.so.conf.d/的作用就比较清晰了。', 'Ubuntu');
INSERT INTO `question` VALUES ('100', '目录结构', '/usr/bin   gcc等系统安装程序所在目录\n/usr/local/bin opencv等自己安装程序所在目录\n/usr/local/include c++需要包含头文件所在目录', 'Ubuntu');
INSERT INTO `question` VALUES ('101', 'vscode安装', '1、官网下载安装包，解压。\n\ntar zxvf code-stable-code_1.23.1-1525968403_amd64.tar.gz\n\n2、移动：\n\nsudo mv VSCode-linux-x64  /usr/local/\n\n3、添加权限\n\nchmod +x /usr/local/VSCode-linux-x64/code\n\n4、复制图标\n\nsudo cp /usr/local/VSCode-linux-x64/resources/app/resources/linux/code.png  /usr/share/icons/\n\n5、创建启动器\n\ncd  ~/Desktop\n\nvi  VSCode.desktop\n\n输入以下内容：\n\n[Desktop Entry]\nName=Visual Studio Code\nComment=Multi-platform code editor for Linux\nExec=/usr/local/VSCode-linux-x64/code\nIcon=/usr/share/icons/code.png\nType=Application\nStartupNotify=true\nCategories=TextEditor;Development;Utility;\nMimeType=text/plain;\n\n保存退出，右键 -- Properties -- Permissions -- Allow excuting file as program', 'Ubuntu');
INSERT INTO `question` VALUES ('102', 'ls命令', 'ls -a（显示所有文件，包扩隐藏文件)', 'Ubuntu');
INSERT INTO `question` VALUES ('103', '修改权限', 'sudo chmod 777 文件名 （可以对文件夹操作）更改文件权限，比如root使root可以访问\nsudo chmod a+x 添加可执行权限', 'Ubuntu');
INSERT INTO `question` VALUES ('104', '安装显卡驱动', 'ubuntu-drivers devices 检查硬件信息\nubuntu-drivers autoinstall 自动安装驱动', 'Ubuntu');
INSERT INTO `question` VALUES ('105', '打不开磁盘', '用ntfsfix命令解决，首先这个命令依赖于ntfs-3g这个包，如果没有安装，首先要按照以下命令安装：\nsudo apt-get install ntfs-3g\n\n然后一一用ntfsfix修复对应的分区，比如出现“Error mounting /dev/sda9 at/media”的错误，则用以下命令修复，修复完就可以访问。\n\nsudo ntfsfix /dev/sda\n\n', 'Ubuntu');
INSERT INTO `question` VALUES ('106', 'cmake各版本下载', 'https://cmake.org/files/', 'windows');
INSERT INTO `question` VALUES ('107', '拷贝构造函数与=运算符', 'Test t1(100,200); \nTest t2=t1;//调用拷贝构造函数 \nTest t3(t1);//调用拷贝构造函数 \nTest t4; \nt4=t3;调用=运算符 \nclass Test \n{ \npublic: \nTest(const Test & another) \n{ \n   m_x=another.m_x; \n   m_y=another.m_y; \n} \n  \nvoid operator=(const Test & another) \n { \n     m_x=another.m_x; \n     m_y=another.m_y; \n} \nprivate: \nint m_x; \nint m_y; \n} ', 'c++');
INSERT INTO `question` VALUES ('108', '常用函数', 'invert_image (ImageReduced, ImageInvert)//黑白互转\nzoom_image_size  //图像resize', 'Halcon');
INSERT INTO `question` VALUES ('109', '.run文件', '.run文件可以直接./文件名.run进行运行', 'Ubuntu');
INSERT INTO `question` VALUES ('110', 'cmake Ubuntu', ' 它所做的事其实就是告诉编译器如何去编译链接源代码这里就牵涉到跨平台问题。在windows平台下是通过project文件去管理这些的，如果不用cmake，那我们为window和linux系统就要写对应的project文件和makefile文件，这无疑是一件繁琐的事，而我们只要编写一次cmake，就可以用在各个平台，而且其语法也简单。这就是所谓的“write once，use everywhere”。\n#cmake最小需要版本 cmake_minimum_required(VERSION 2.8) #项目名字 project(HELLOWORLD) #包含原程序,即把给定目录下的源程序复制给变量DIR_SRC aux_source_directory(DIR_SRC ./) #生成程序 add_executable(helloworld ${DIR_SRC})\n\n#cmake最小需要版本 cmake_minimum_required(VERSION 2.8) #项目名字 project(HELLOWORLD) #包含原程序,即把给定目录下的源程序复制给变量DIR_SRC aux_source_directory(DIR_SRC ./) #生成程序 add_executable(helloworld ${DIR_SRC})\n\n\n1.卸载旧版本\napt-get autoremove cmake\n2.以安装3.12.3版本为例\n$ sudo apt-get install build-essential\n$ wget http://www.cmake.org/files/v3.12/cmake-3.12.3.tar.gz\n3.解压、安装\n$ tar xf cmake-3.12.3.tar.gz\n$ cd cmake-3.11.3\n$ ./configure\n$ make\n$ sudo make install\n4.解决路径问题\nexport PATH=/usr/local/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH\ncmake\n5.查看，安装成功\ncmake --version', 'Ubuntu');
INSERT INTO `question` VALUES ('111', 'opencv的安装', '下载地址大全：https://opencv.org/releases.html\nwget https://github.com/opencv/opencv/archive/3.4.0.zip\nwget https://github.com/opencv/opencv/archive/3.2.0.zip\nunzip 3.4.0.zip\nsudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev\ncd opencv-3.4.0\nmkdir build\ncd build\ncmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..\nmake\nsudo make install', 'Ubuntu');
INSERT INTO `question` VALUES ('112', '配置vscode项目', 'launch.json,task.json,c_cpp_properties.json\n\nF5\nlaunch.json\n\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n\n        {\n            \"name\": \"(gdb) Launch\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            //\"program\": \"enter program name, for example ${workspaceFolder}/a.exe\",\n            \"program\": \"${file}.o\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": true,\n            \"MIMode\": \"gdb\",\n            \"miDebuggerPath\": \"C:MinGWmingw64ingdb.exe\",\n            \"preLaunchTask\": \"g++\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ]\n        }\n    ]\n}\n\n.vscode 文件夹下建立下面文件\nc_cpp_properties.json\n\n{\n    \"configurations\": [\n        {\n            \"name\": \"Win32\",\n            \"includePath\": [\n                \"D:/opencv/build/include\",//这里引入opencv源文件路径,下面两个地址都是\n                \"${workspaceFolder}/**\",\n                \"D:/opencv/build/include/opencv\",\n                \"D:/opencv/build/include/opencv2\"\n            ],\n            \"defines\": [\n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\"\n            ],\n            \"compilerPath\": \"C:\\MinGW\\mingw64\\bin\\gcc.exe\",\n            \"cStandard\": \"c11\",\n            \"cppStandard\": \"c++17\",\n            \"intelliSenseMode\": \"clang-x64\"\n        }\n    ],\n    \"version\": 4\n}\n\nctrl shift p\ntask.json\n\n{\n    // See https://go.microsoft.com/fwlink/?LinkId=733558\n    // for the documentation about the tasks.json format\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n           {\n            \"label\": \"g++\",\n            \"type\": \"shell\",\n            \"command\": \"g++\",\n            \"args\": [     \"-g\",  \"${file}\",  \"-o\",  \"${file}.o\",//这里添加动态链接库\n                        \"-I\",\"D:/opencv/build/include\",\n                        \"-I\",\"D:/opencv/build/include/opencv\",\n                        \"-I\",\"D:/opencv/build/include/opencv2\",\n                        \"-L\", \"D:/opencv/build/x64/mingw/lib\",\n                        \"-l\", \"opencv_core330\",\n                        \"-l\", \"libopencv_imgproc330\",\n                        \"-l\", \"libopencv_video330\",\n                        \"-l\", \"libopencv_ml330\",\n                        \"-l\", \"libopencv_highgui330\",\n                        \"-l\", \"libopencv_objdetect330\",\n                        \"-l\", \"libopencv_flann330\",\n                        \"-l\", \"libopencv_imgcodecs330\",\n                        \"-l\", \"libopencv_photo330\",\n                        \"-l\", \"libopencv_videoio330\"\n                ],\n            \"problemMatcher\": {    \n                \"owner\": \"cpp\",      \n                \"fileLocation\": [      \n                    \"relative\",      \n                    \"${workspaceRoot}\"      \n                ],      \n                \"pattern\": {      \n                    \"regexp\": \"^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$\",      \n                    \"file\": 1,      \n                    \"line\": 2,      \n                    \"column\": 3,      \n                    \"severity\": 4,      \n                    \"message\": 5      \n                }      \n            } \n        }\n    ]\n}\n', 'Ubuntu');
INSERT INTO `question` VALUES ('113', 'gflags  caffe相关包的安装', 'git clone https://github.com/gflags/gflags\ncd gflags\ncmake ..-DBUILD_SHARED_LIBS=ON -DCMAKE_CXX_FLAGS=-fPIC ..\n\nmake -j12\nsudo make install', 'Ubuntu');
INSERT INTO `question` VALUES ('114', 'BLAS  caffe相关包的安装', 'git clone git://github.com/xianyi/OpenBLAS\ncd OpenBLAS\nmake -j\nmake PREFIX=/home/dl/local_install/ install', 'Ubuntu');
INSERT INTO `question` VALUES ('115', 'lmdb  caffe相关包的安装', 'git clone https://github.com/LMDB/lmdb\n    cd lmdb/libraries/liblmdb\n    make && make install', 'Ubuntu');
INSERT INTO `question` VALUES ('116', 'leveldb caffe相关包的安装', 'git clone https://github.com/google/leveldb.git\ncd leveldb\nmkdir build\ncd build\ncmake ..\nmake -j', 'Ubuntu');
INSERT INTO `question` VALUES ('117', 'snapppy  caffe相关包的安装', 'tar zxvf snappy-1.1.3.tar.gz \ncd snappy-1.1.3/\n./configure --prefix=/home/dl/local_install/\nmake -j12 && make install', 'Ubuntu');
INSERT INTO `question` VALUES ('118', 'boost  caffe相关包安装', '下载好了以后，解压 .bz2 文件\n\n    tar jxvf xx.tar.bz2\n\n解压之后，进入解压目录，执行：\n\n./bootstrap.sh  --with-libraries=system,thread,python\n\nsudo ./b2\nsudo ./b2 install\n\ncp -r boost/ /home/dl/local_install/include/\ncp stage/lib/* /home/dl/local_install/lib/\n\nstep3：测试\n#include<iostream>\n#include<boost/bind.hpp>\nusing namespace std;\nusing namespace boost;\nint fun(int x,int y){return x+y;}\nint main(){\n    int m=1;int n=2;\n    cout<<boost::bind(fun,_1,_2)(m,n)<<endl;\n    return 0;\n}', 'Ubuntu');
INSERT INTO `question` VALUES ('119', 'protobuf   caffe相关包的安装', '下载地址：https://github.com/protocolbuffers/protobuf/releases\n tar -xzf protobuf-2.1.0.tar.gz \n cd protobuf-2.1.0 \n ./configure --prefix=/usr/local/protobuf\n make \n make check \n make install ', 'Ubuntu');
INSERT INTO `question` VALUES ('120', '打不开windows磁盘', 'Error mounting /dev/nvme0n1p4 at /media/dl/Windows: Command-line `mount -t \"ntfs\" -o\n#! /bin/bash\nsudo mkdir -p /media/andy/DataTools\nsudo chmod 777 /media/andy/DataTools\nsudo mount -t ntfs -ro nls=utf8,umask=0222 /dev/nvme0n1p4 /media/andy/DataTools', 'Ubuntu');
INSERT INTO `question` VALUES ('121', 'python2和python3切换', '1.首先在ubuntu的终端ternimal输入命令：（查看系统里有没有python3）\nsudo apt-get install python3.5\n删除原来默认指向python2.7版本的链接。\nsudo rm /usr/bin/python\n重新指定新的链接给python3.5版本。\nsudo ln -s /usr/bin/python3.5 /usr/bin/python \n\n另：python2.7和3.5版本之间随意切换（这里3.5切换回2.7版本）：\nsudo rm /usr/bin/python\nsudo ln -s /usr/bin/python2.7 /usr/bin/python', 'Ubuntu');
INSERT INTO `question` VALUES ('122', '输入pip命令报错', 'from pip import main ImportError: cannot import name main\n//修改前 from pip import main if __name__ == __main__: sys.exit(main()) 修改后 from pip import __main__ //这行也要修改 if __name__ == __main__: sys.exit(__main__._main())//增加__main__._', 'Ubuntu');
INSERT INTO `question` VALUES ('123', 'git log', '(HEAD是一个指针，移动版本的时候就是在移动指针) ', 'Git');
INSERT INTO `question` VALUES ('124', '常用函数', '增加工作路径\nimport sys\nsys.path.append(\'./samples/\')\n\n查看类或变量的所有属性和方法：dir(keras.layers)\n\nlist(range(20))生成1-20的数组（list）元组转数组\n\nzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。\n如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。\nzip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。\na = [1,2,3]\nb = [4,5,6]\nc = [4,5,6,7,8]\nzipped = zip(a,b)     # 打包为元组的列表\n[(1, 4), (2, 5), (3, 6)]\nzip(a,c)              # 元素个数与最短的列表一致\n[(1, 4), (2, 5), (3, 6)]\n\ndict数组二元组转字典', 'Python');
INSERT INTO `question` VALUES ('125', '说明', '不支持单引号直接输入，需要用“ \\\' ”替换“ \' ”', 'AboutMe');
INSERT INTO `question` VALUES ('126', 'pip用法', 'pip安装git地址\npip install git+http网址(clone地址)#subdirectory=子文件夹名\n例：pip install git+https://github.com/philferriere/cocoapi.git#subdirectory=PythonAPI', 'Python');
INSERT INTO `question` VALUES ('127', 'setup.py编译生成文件格式', '_包名\nwindows 生成.pyd文件\nubuntu生成.so文件', 'Python');
INSERT INTO `question` VALUES ('128', 'Mask rcnn笔记', 'windows安装pycocotools包\npip install git+http网址#subdirectory=子目录名\n例：pip install git+https://github.com/philferriere/cocoapi.git#subdirectory=PythonAPI', 'Python');
INSERT INTO `question` VALUES ('129', '类', 'class 类名(父类名):\n  def __init__(self,name):\n     self.name=name\n  def detect(self,image):\n     cv2.imshow(\'image\',image)\n\n__init__方法用于初始化类，每个方法需要传入self参数，创建属性直接在方法里self.name= 即可，无需声明。', 'Python');
INSERT INTO `question` VALUES ('130', '分类问题和回归问题', '分类问题：模型的输出是概率分布 [0.2,0.7,0.1] \n回归问题：模型的输出是一个预测值，模型的输出是一个实数 \n回归问题： \n1.       参数是逐步调整的。 \nOne-hot编码，把正整数表达为向量 ，生成一个长度不小于正整数的向量，只有正整数的位置处为1。 \n2.       分类问题的损失函数： \n平方差损失，交叉熵损失。 \n分类问题： \n预测值与真实值的差距。 \n损失函数：平方差损失，绝对值损失。 \n', 'DeepLearning');
INSERT INTO `question` VALUES ('131', '激励函数', 'relu: y=max(0,x) \nsoftmax:将向量变成概率分布。x=[x1,x2,x3], y=[e^x1/sum,e^x2/sum,e^x3/sum],sum=e^x1+e^x2+e^x3 ', 'DeepLearning');
INSERT INTO `question` VALUES ('132', 'Tensorflow版本与cuda、cudnn版本对应', 'Tensorflow 1.5.0  cuda 9.0 cudnn 7.0.5 \nTensorflow 1.14.0  cuda 10.0 cudnn 7.6.5 ', 'Python');
INSERT INTO `question` VALUES ('133', '读取文本文件', 'with open(\"test.txt\", \"r\") as f:\n    data = f.readlines()\n    print(data)', 'Python');
INSERT INTO `question` VALUES ('134', 'keras创建模型和使用', 'model=keras.models.Sequential()//创建模型\nmodel.add(keras.layers.Flatten(input_shape=[28,28]))//开始添加层\nmodel.add(keras.layers.Dense(300,activation=\"relu\"))\nmodel.add(keras.layers.Dense(100,activation=\"relu\"))\nmodel.add(keras.layers.Dense(10,activation=\"softmax\"))\n#compile方法添加损失函数，优化方法，关心的值，sparse_categorical_crossentropy将y的索引转化为one-hot形式，如果已经是one-hot形式使用categorical_crossentropy就可以\nmodel.compile(loss=\"sparse_categorical_crossentropy\",optimizer=\"sgd\",metrics=[\"accuracy\"])', 'DeepLearning');
INSERT INTO `question` VALUES ('135', 'python lambda表达式', 'lambda argument_list: expression\nargument_list是参数列表，它的结构与Python中函数(function)的参数列表是一样的（输入）\nexpression是一个关于参数的表达式。表达式中出现的参数需要在argument_list中有定义，并且表达式只能是单行的（输出）\nlambda函数：又称“匿名函数”\nlambda函数有输入和输出：输入是传入到参数列表argument_list的值，输出是根据表达式expression计算得到的值。\nlambda函数功能简单：单行expression决定了lambda函数不可能完成复杂的逻辑\n二、示例\nlambda x, y: x*y；函数输入是x和y，输出是它们的积x*y\nlambda:None；函数没有输入参数，输出是None\nlambda *args: sum(args); 输入是任意个数的参数，输出是它们的和(隐性要求是输入参数必须能够进行加法运算)\nlambda **kwargs: 1；输入是任意键值对参数，输出是1', 'Python');
INSERT INTO `question` VALUES ('136', 'vs qt版本错误', '解决方案（非项目），右键-》Change Solution Versions修改解决方案的qt版本', 'qt');
INSERT INTO `question` VALUES ('137', '本地恢复远程库版本，放弃所有修改', 'git checkout .（貌似有效，待测试）\ngit log  git reset commit后面的长串（貌似没有效果）\n', 'Git');
INSERT INTO `question` VALUES ('138', '回调函数callbacks', 'EarlyStopping 需要的时候(loss不再下降)提前终止 \nModelCheckpoint（每隔一段时间保存） \nTensorBoard 可视化工具，模型训练中查看 ', 'DeepLearning');
INSERT INTO `question` VALUES ('139', '提升分类准确率的方法', '1.  对数据归一化 \n2.   批量归一化。 \n对数据归一化： \nX=(x-u)/std \n数据归一化代码（图像分类问题）：\n#对数据归一化\nfrom sklearn.preprocessing import StandardScaler\nscaler=StandardScaler()\n#用这个函数进行归一化需要将数据格式转换为二维x_train:[None,28,28]->[None,784]\n#fit_transform记录训练集的均值和方差用于验证集和测试集\nx_train_scaled=scaler.fit_transform(x_train.astype(np.float32).reshape(-1,1)).reshape(-1,28,28)\nx_valid_scaled=scaler.transform(x_valid.astype(np.float32).reshape(-1,1)).reshape(-1,28,28)\nx_test_scaled=scaler.transform(x_test.astype(np.float32).reshape(-1,1)).reshape(-1,28,28)\n\n', 'DeepLearning');
INSERT INTO `question` VALUES ('140', ' tree命令', '打印目录结构', 'Ubuntu');
