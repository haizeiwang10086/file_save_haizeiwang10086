/*
Navicat MySQL Data Transfer

Source Server         : dh
Source Server Version : 50560
Source Host           : localhost:3306
Source Database       : test

Target Server Type    : MYSQL
Target Server Version : 50560
File Encoding         : 65001

Date: 2019-12-18 10:35:57
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `question`
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 DEFAULT NULL,
  `content` longtext CHARACTER SET utf8,
  `label` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=latin1;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES ('2', 'VS工作目录', '属性-》调试-》工作目录', 'c++');
INSERT INTO `question` VALUES ('3', '不能使用默认构造函数', '类中有其它复杂的类成员，且该类成员没有默认的构造函数，此时无法调用这个类的默认的构造函数（默认的构造函数时已删除的函数） ', 'c++');
INSERT INTO `question` VALUES ('4', '数据库占位符的使用', 'query->prepare(\"select * from question where id=?\")；\nquery->addBindValue(0,3)\n', 'qt');
INSERT INTO `question` VALUES ('6', 'qt连接数据库', '#include \"qsqldatabase.h\"\n#include \"qsqlquery.h\"\n\nQSqlDatabase db;\nQSqlQuery *query;\ndb.setDatabaseName(mConf.find(\"data_base_name\")->second);\n            db.setHostName(\"localhost\");\n            db.setUserName(mConf.find(\"user_name\")->second);\n            db.setPassword(mConf.find(\"db_password\")->second);\n            if (db.open())\n            {\n                query = new QSqlQuery(db);\n                isDbOpen = true;\n            }\nquery->exec(\"select * from info\");\n', 'qt');
INSERT INTO `question` VALUES ('7', 'QMainWindow', 'QMainWindow主要在windows下使用 ', 'qt');
INSERT INTO `question` VALUES ('8', 'QWidget', 'QWidget常用基类。窗口类的基类 ', 'qt');
INSERT INTO `question` VALUES ('9', 'QPushButton ', 'QPushButton b; \n    b.setText(\"lll\");//给按钮设置内容 \n    //b.show(); \n    /*如果不指定父对象，对象和对象（窗口和窗口）是没有关系的 \n    1.setParent（父对象显示，子对象自动显示） \n    2.通过构造杉树传参*/ \n    b.setParent(&w); \n    b.move(100,100); \n    b.show(); \n    QPushButton b1(&w);//通过构造函数传参 \n    b1.setText(\"bcd\"); \nb1.show(); \nb1.setStyleSheet(\"background: rgb(0,255,0));设置按钮背景颜色', 'qt');
INSERT INTO `question` VALUES ('10', '信号与槽函数', '/*&b1 信号发出者，指针类型 \n     * &QPushButton::pressed  处理的信号， 发送者的类名::处理的信号 \n     * this 信号接收者，指针类型 \n     * &MyWidget::close      槽函数 信号处理函数   接受者的类名::槽函数名 \n     */ \nQT4槽函数必须有slots关键字来修饰 \nconnect(&b1,&QPushButton::pressed,this,&MyWidget::close); \n  \n/*自定义槽函数，普通函数的用法 \n     * Qt5: 任意的成员函数，普通全局函数，静态函数 \n     * 槽函数需要和信号一致（参数，返回值） \n     * 由于信号都是没有返回值，所以槽函数一定没有返回值 \n    */ \nvoid mySlot(); \nconnect(&b1,&QPushButton::released,this,&MyWidget::mySlot); \n/*信号必须有signals关键字来声明 \n     * 信号没有返回值，但可以有参数 \n     * 信号就是函数的声明，只需声明无需定义 \n     * 使用 emit mySignal(); \n     * 信号可以重载 \n     */ \nsignals: \n    void mySignal(); \nvoid mySignal(int,QString); ', 'qt');
INSERT INTO `question` VALUES ('11', 'QDebug qt打印输出', '和c++  cout的用法一样，用的时候qDebug()<<a<<str; ', 'qt');
INSERT INTO `question` VALUES ('12', '函数指针和函数多态', '函数指针  void (*p)(int)=fun; \n信号多态处理  void (SubWidget::*testWidget)(int,QString)=SubWidget::mySignal; ', 'c++');
INSERT INTO `question` VALUES ('13', 'qt lambda表达式 需要.pro文件添加c++11', 'CONFIG+=C++11 \nconnect(b3,&QPushButton::released, [b3,a,b]()//a,b为只读，加关键字后可以修改\n[b3,a,b]() mutable { b3->setText(\"~_~\"); });\n [=]()lambda表达式中等号表示把外部所有局部变量、类中所有成员以值传递方式传入或者可可以自己写需要传递的值\n[b3,a,b] [&]()引用方式传入 ', 'qt');
INSERT INTO `question` VALUES ('14', '坐标系统', '1)对于窗口坐标原点在屏幕左上角，对于按钮坐标原点在窗口白色区域左上角 \n2)子窗口原点为相对于父窗口', 'qt');
INSERT INTO `question` VALUES ('15', 'qt内存管理机制', '直接或间接继承于QObject的类，指定父对象后，子对象如果是动态分配控件的new，不需要手动释放delete,系统会自动释放', 'qt');
INSERT INTO `question` VALUES ('16', 'QMenuBar 菜单条', 'QMenuBar *mBar=menuBar(); \n//添加菜单选项 \nQMenu *pFile=mBar->addMenu(\"文件\"); \n//添加菜单动作 \nQAction *pAction=pFile->addAction(\"new\"); ', 'qt');
INSERT INTO `question` VALUES ('17', 'QToolBar 工具栏', 'QAction *pAction;\nQToolBar *toolBar=addToolBar(\"tool Bar\"); \n    //工具栏添加快捷键,使用前面的指针就可以 \ntoolBar->addAction(pAction); \nQPushButton *b=new QPushButton; \nb->setText(\"1_1\"); \ntoolBar->addWidget(b); ', 'qt');
INSERT INTO `question` VALUES ('18', 'QStatusBar 状态栏', 'QStatusBar *statBar=statusBar(); \nQLabel *label=new QLabel(this); \nlabel->setText(\"Normal text file\"); \nstatBar->addWidget(label);//从左向右添加 \nstatBar->addWidget(new QLabel(\"3\",this)); \nstatBar->addPermanentWidget(new QLabel(\"6\",this));//从右向左添加 ', 'qt');
INSERT INTO `question` VALUES ('19', '#include <QAxWidget> 找不到文件', '修改pro文件，添加 QT += axcontainer ', 'qt');
INSERT INTO `question` VALUES ('20', 'MySql 动态库放置路径libmySQL.dll', 'D:QT5.9.2mingw53_32in ', 'qt');
INSERT INTO `question` VALUES ('21', 'release模式下无法调试', '属性页-》c/c++ -> 常规-》调试信息格式：程序数据（/Zi）\n         连接器-》调试-》生成调试信息：优化以便于调试(/DEBUG)', 'qt');
INSERT INTO `question` VALUES ('22', 'qt快捷键', 'F4跳到对应的.cpp', 'qt');
INSERT INTO `question` VALUES ('23', '中心控件', 'QTextEdit *qte=new QTextEdit(this);文本编辑 \nsetCentralWidget(qte);设置中心控件 ', 'qt');
INSERT INTO `question` VALUES ('24', '浮动窗口', 'QDockWidget *dock=new QDockWidget(this);//浮动窗口 \naddDockWidget(Qt::RightDockWidgetArea,dock);//主窗口增加浮动窗口 \nQTextEdit *dockQte=new QTextEdit(this);//文本编辑窗口 \ndock->setWidget(dockQte);//浮动窗口增加文本编辑器 ', 'qt');
INSERT INTO `question` VALUES ('25', '模态对话框', ' QDialog dlg;\ndlg.exec();//阻塞对话框', 'qt');
INSERT INTO `question` VALUES ('26', '非模态对话框', 'QDialog dlg; \n//  dlg.show(); //显示对话框不阻塞,函数运行完变量删除，对话框一闪消失 ', 'qt');
INSERT INTO `question` VALUES ('27', 'QDialog 对话框', 'QDialog dlg; \ndlg.show(); //显示对话框不阻塞,函数运行完变量删除，对话框一闪消失 \ndlg.exec();//阻塞对话框\nQDialog *dlg=new QDialog(this); \ndlg->setAttribute(Qt::WA_DeleteOnClose);//文本框关闭后删除 \n                   dlg->show(); ', 'qt');
INSERT INTO `question` VALUES ('28', 'QMessageBox 消息对话框', 'QMessageBox::about(this,\"关于QT\",\"对话框测试\");//消息对话框 \n                int ret=QMessageBox::question(this,\"question\",\"Are you ok?\"); ', 'qt');
INSERT INTO `question` VALUES ('29', 'QFileDialog 文件对话框', ' QString path=QFileDialog::getOpenFileName( \n                            this, \n                            \"open\", \n                            \"../\", \n                            tr(\"source(*.cpp *.h);;Text(*.txt);;all(*.*)\")); ', 'qt');
INSERT INTO `question` VALUES ('30', '消息对话框中文乱码', 'QStringLiteral类用于解决qt中的乱码问题\nQStringLiteral(\"中文信息\"); \n\n窗口标题乱码\n\nsetWindowTitle(QString::fromUtf16(u\"管理工具\"));', 'qt');
INSERT INTO `question` VALUES ('31', 'vs运行qt 中文乱码问题', '1.  //在头文件前面加上下面几行代码 \n2.  #ifdef WIN32  \n3.  #pragma execution_character_set(\"utf-8\")  \n4.  #endif ', 'qt');
INSERT INTO `question` VALUES ('32', 'resizeEvent重写窗口大小改变事件', '.h文件中添加声明\npublic:\nvoid resizeEvent(QResizeEvent * event)\n.cpp文件中重写这个函数', 'qt');
INSERT INTO `question` VALUES ('35', 'QTabWidget 主窗口左侧功能栏', '需要功能菜单显示在左侧，且文字水平，需要重写QProxyStyle（见最下面）\n\n最后再 ui.tabWidget->tabBar()->setStyle(new CustomTabStyle);\n\n用法：ui.tabWidget->addTab(&docDisp, \"Main\");增加新的窗口docDisp 是一个QWidget类\n标签切换触发事件：connect(ui.tabWidget, &QTabWidget::currentChanged, this, &DocManagement::dealTabClick);\nclass CustomTabStyle : public QProxyStyle\n{\npublic:\n    QSize sizeFromContents(ContentsType type, const QStyleOption *option,\n        const QSize &size, const QWidget *widget) const;\n\n    void drawControl(ControlElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const;\n \n};\n\n\ncpp文件\n\n#include \"CustomTabStyle.h\"\n\n\n\nQSize CustomTabStyle::sizeFromContents(ContentsType type, const QStyleOption *option,\n    const QSize &size, const QWidget *widget) const\n{\n    QSize s = QProxyStyle::sizeFromContents(type, option, size, widget);\n    if (type == QStyle::CT_TabBarTab)\n    {\n        s.transpose();\n        s.rwidth() = 70;\n        s.rheight() = 30;\n    }\n    return s;\n}\n\nvoid CustomTabStyle::drawControl(ControlElement element, const QStyleOption *option, QPainter *painter, const QWidget *widget) const\n{\n    if (element == CE_TabBarTabLabel) {\n        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {\n            QRect allRect = tab->rect;\n\n            if (tab->state & QStyle::State_Selected) {\n                painter->save();\n                painter->setPen(0x89cfff);\n                painter->setBrush(QBrush(0x89cfff));\n                painter->drawRect(allRect.adjusted(1, 3, -1, -6));\n                painter->restore();\n            }\n            QTextOption option;\n            option.setAlignment(Qt::AlignCenter);\n            if (tab->state & QStyle::State_Selected) {\n                painter->setPen(0xf8fcff);\n            }\n            else {\n                painter->setPen(0x5d5d5d);\n            }\n            painter->drawText(allRect, tab->text, option);\n            return;\n        }\n    }\n\n    if (element == CE_TabBarTab) {\n        QProxyStyle::drawControl(element, option, painter, widget);\n    }\n}\n\n', 'qt');
INSERT INTO `question` VALUES ('38', 'vs qt 修改左上角图标', '在项目目录中添加XXX.qrc，添加内容：\n<RCC>\n    <qresource>\n      	  <file>images/sync.ico</file>\n	  <file>images/search.ico</file>\n	  <file>images/new.ico</file>\n    </qresource>\n</RCC>\n新建文件夹image,并将myapp.ico文件放到文件夹中，多个图标，添加多个路径即可，项目上右键-》添加现有项-》选择XXX.qrc文件\n项目中添加代码\nQIcon icon;\nicon.addFile(\":/image/myapp.ico\");\nsetWindowIcon(icon);\n\n按钮可以在ui界面设置图标，选择资源方式添加，选择对应的qrc文件', 'qt');
INSERT INTO `question` VALUES ('39', 'MFC空项目创建', '新建项目-》Visual C++ ->MFC->MFC 应用程序-》下一步-》基于对话框-》完成', 'MFC\n');
INSERT INTO `question` VALUES ('40', 'MessageBox', 'HWND hWnd = ::FindWindow(NULL, _T(\"新建文本文档 (2).txt - 记事本\"));//获取了一个窗口\n\nMessageBox(_T(\"第一个对话框\"), _T(\"提示\"),  MB_YESNOCANCEL|MB_ICONERROR);; //（对话框显示内容，对话框标题，对话框按钮类型）\nMB_ICONERROR图标类型\n该函数返回值为ok,no等按钮的宏定义（IDOK）。\n\n\nF12转到定义', 'MFC');
INSERT INTO `question` VALUES ('41', '图标|资源|对话框', '工程上点右键-》添加-》新建项-》资源-》资源文件（.rc）\n资源视图中找到刚才创建的.rc文件->右键-》添加资源（包括位图资源，光标资源，图标资源，等等）-》Icon(导入)/Dialog(对话框)-》编译（一般使用id最小的图标，在Resource.h里查看）\n\n\n资源：图标，光标，对话框...', 'MFC');
INSERT INTO `question` VALUES ('42', 'coding', '进入项目：\n任务-》里程碑（创建里程碑）\n       任务列表（创建任务）\n代码-》浏览代码，管理分支\n项目设置-》退出项目', 'windows\n');
INSERT INTO `question` VALUES ('43', 'OpenCv模板匹配', '    Mat img = imread(\"../images/tmp.tif\",1);\n    Mat img1 = imread(\"../images/2019_10_17_9_8_3_426_Z.tif\", 1);\n    if (img.empty()| img1.empty())\n    {\n        cout << \"load image failed...\" << endl;\n    }\n\n    Mat result;\n    matchTemplate(img1, img, result,4);\n    normalize(result, result, 0, 1, CV_MINMAX);\n    Point minLoc, maxLoc;\n    double minVal,maxVal;\n    minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());\n    rectangle(img1, Rect(maxLoc.x, maxLoc.y, img.cols, img.rows), Scalar(0, 255, 255), 2, 8);\n    namedWindow(\"result\", CV_NORMAL);\n    imshow(\"result\", img1);\n    \n    waitKey(0);\n\n    TM_SQDIFF        = 0\n    TM_SQDIFF_NORMED = 1\n    TM_CCORR         = 2\n    TM_CCORR_NORMED  = 3\n    TM_CCOEFF        = 4\n    TM_CCOEFF_NORMED = 5', 'opencv');
INSERT INTO `question` VALUES ('44', 'QImage用法', 'cv::Mat mat(1024,800,CV_8UC1);\nuchar *pSrc=mat.data;\nQImage image(mat.cols,mat.rows,QImage::Format_Indexed8)\n//QImage::Format_Indexed8  显示灰度图像\n\nimage.setColorCount(256);\nfor(int i=0;i<256;i++)\n{\n   image.setColor(i,qRgb(i,i,i));\n}\nfor(int r=0;r<mat.rows;r++)\n{\n   uchar *pDst=image.scanLine(r)//行数据首地址\n   memcpy(pDst,pSrc,mat.cols);\n   pSrc+=mat.step;\n}\n', 'qt');
INSERT INTO `question` VALUES ('45', 'Edit Control', '对.rc文件中的Dialog ui界面给Edit Control控件添加变量，在*Dlg.h文件中将变量类型修改为CEditEx（自定义的一个类）,实现这个类，在类中对编辑框输入的内容进行定义\n\n//头文件\n#pragma once\n\n\n// CEditEx 对话框\nclass CEditEx : public CEdit\n{\n    DECLARE_DYNAMIC(CEditEx)\n\npublic:\n    CEditEx();\n    virtual ~CEditEx();\n\nprotected:\n    DECLARE_MESSAGE_MAP()\npublic:\n    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);\n    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);\n};\n\n//cpp文件\n\n// EditEx.cpp : 实现文件\n//\n#include \"stdafx.h\"\n#include \"EditEx.h\"\n\n// CEditEx\n\nIMPLEMENT_DYNAMIC(CEditEx, CEdit)\n\nCEditEx::CEditEx()\n{\n}\n\nCEditEx::~CEditEx()\n{\n    \n}\n//algstitchcheck项目中查看', 'MFC');
INSERT INTO `question` VALUES ('47', '编辑框背景颜色', '.rc文件中找到对话框，右键-》类向导-》消息-》WM_CTLCOLOR->添加处理程序-》编辑代码，cpp文件中函数里添加如下代码：\n\nHBRUSH CPropDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)\n{\n    HBRUSH hbr = CBCGPDialog::OnCtlColor(pDC, pWnd, nCtlColor);\n\n    if (nCtlColor == CTLCOLOR_EDIT &&\n            (pWnd->GetDlgCtrlID() == IDC_EDIT1 || \n                pWnd->GetDlgCtrlID() == IDC_EDIT2))\n    {\n        pDC->SetTextColor(RGB(255, 255, 255));\n        pDC->SetBkColor(RGB(0, 120, 215));//文本背景\n        hbr = CreateSolidBrush(RGB(37, 37, 37));//编辑框背景\n    }\n        \n\n     \n    return hbr;\n}', 'MFC');
INSERT INTO `question` VALUES ('48', 'DialogBox', '设置字体-》窗口初始化-》显示。。。。。\n需要支持拖动文件，将Accept Files设置为true（添加消息判断if(WM_DROPFILES==uMsg){}）\n//消息=消息号码+附加数据\nBOOL CALLBACK MainProc\n(\n	HWND hwndDlg,//本对话框句柄,修改消息的标题，移动窗口\n	UINT uMsg,//消息句柄，消息号码\n	WPARAM wParam,//uMsg携带的数据\n	LPARAM lParam//第二个参数\n	)\n{\n	CString s;\n	s.Format(_T(\"uMsg=%d,wParam=%d,lParam=%d\"), uMsg, wParam, lParam);\n\n	OutputDebugString(s);//可以在输出窗口输出\n	if (WM_COMMAND == uMsg)//WM windows 开头的都是windows信号，附带的消息，wParam,lParam\n	{\n		if (LOWORD(wParam) == IDCANCEL)//取低字节数据\n		{\n			EndDialog(hwndDlg, IDCANCEL);\n		}\n		if (LOWORD(wParam) == IDOK)\n		{\n		            int nLeft = GetDlgItemInt(hwndDlg, IDC_EDIT1,NULL,TRUE);//最后一个参数bSigned 是否有符号的数据类型标识\n			int nMid = GetDlgItemInt(hwndDlg, IDC_EDIT2, NULL, TRUE);\n			int nResut = nLeft + nMid;\n			SetDlgItemInt(hwndDlg, IDC_EDIT3, nResut, TRUE);\n		}\n	}\n	//截获按钮的操作\n	return FALSE;//一般return false由系统处理后面的任务\n}\nDialogBox(NULL, (LPCWSTR)IDD_CAP2_DIALOG, NULL, MainProc);//HINSTANCE ,LPCWSTR, ,回调函数', 'MFC');
INSERT INTO `question` VALUES ('49', 'UItralSO制作启动盘', '文件-》打开-》选择ISO镜像文件\n启动-》写入硬盘镜像\n\n USB-HDD （ USB Hard Drives 的缩写，硬盘模式）： 硬盘仿真模式，启动后U盘的盘符是C。（注意：这个模式在安装系统时容易混淆U盘和硬盘的C分区）。\n\n        USB-HDD+：增强的USB-HDD模式，DOS启动后显示C盘，兼容性高于USB-HDD模式。但对仅支持USB-ZIP的电脑无法启动。\n\n        USB-HDD + v2：USB-HDD + v2兼容性高于USB-HDD+，有可能支持USB-ZIP的电脑，在dos下启动后U盘盘符仍然显示为C盘。支持隐藏启动分区，可以防病毒、防误删和误格式化等。\n\n        USB-ZIP + v2：比USB-ZIP +多了一个深度隐藏功能。\n\n        至于什么深度隐藏功能还是太高深，我们做启动盘选择USB-HDD或USB-HDD+就行了，一般我都会选择USB-HDD+。\n', 'windows');
INSERT INTO `question` VALUES ('50', 'MFC变量类型', 'HANDLE of Windows =>HWND\nHANDLE of Instance =>HINSTANCE\nHANDLE of Icon =>HICON\n结构体\nPOINT  SIZE  RECT\n简单类型变量\nBOOL （TRUE  FALSE）//WIN32模式下不支持c++语法\nUINT u=20; //usigned int \nWPARAM和UINT一样，只是主要用于消息的传入\nLPARAM和long一个意思\nDWORD   unsigned long\nLONG    long\nWORD    unsigned short\nSHORT   short\nINT     int \n\nint i=10;\nPINT p=&i;所有变量加P指的是指针\nPSTR str=\"asdf\";\nLPSTR ss=\"asdf\";加P和加LP意思一样 char *\nLCSTR  cs=\"asdf\"; const char *\nLPTSTR ?\n1. LPWCH 转成 CString\nLPWSTR   s;  \nCString   cs   =   s;   \n2. CString 转成 LPWCH\nCString   astring(\"ssss\");   \nLPWSTR   pointer;   \npointer=(LPWSTR)(LPCTSTR)astring; \n', 'MFC');
INSERT INTO `question` VALUES ('51', 'Windows快捷键', 'alt + 鼠标左键拖动 .exe文件，松开左键后创建快捷方式', 'windows');
INSERT INTO `question` VALUES ('52', 'static edit', 'static edit 不参与焦点跳转', 'MFC');
INSERT INTO `question` VALUES ('53', 'GetDlgItemText', 'LPWSTR s;\nGetDlgItemText(NULL, IDC_EDIT3, s, sizeof(s));//sizeof的作用是即使编辑框输入更多也不会溢出', 'MFC');
INSERT INTO `question` VALUES ('54', 'Qt自定义控件', 'class MLable : public QLabel{};\n定义自定义类，然后到窗口ui界面，在相应的控件上点击右键-》提升为-》提升的类名输入 MLabel-》添加-》提升', 'qt');
INSERT INTO `question` VALUES ('55', 'Qt事件', 'globalPos()屏幕坐标\npos()窗口坐标\n\n//设置鼠标追踪\nsetMouseTracking(true);\n\nprotected:\n    void mousePressEvent(QMouseEvent *ev);//虚函数\n    void mouseReleaseEvent(QMouseEvent *ev);\n    void mouseMoveEvent(QMouseEvent *ev);\n   //进入窗口区域\n    void enterEvent(QEvent *event);\n    //离开窗口区域\n    void leaveEvent(QEvent *event);\n    void closeEvent(QCloseEvent *e);\n   void keyPressEvent(QKeyEvent *event)\n {\n   if(event->key()==Qt::Key_A)\n   {\n       \n   }\n\n }\n    //计时器功能 \n     void MyWidget::timerEvent(QTimerEvent *event)\n    {\n      构造函数添加int timerId= （startTimer(1000);//以毫秒为单位，每隔一秒调用）  启动定时器\n        取消定时器 killTimer(timerId)\n     static int sec=0;\n     sec++;\n     ui->label->setText(QString(\"<center><h1>Time Out: %1</h1></center>\").arg(sec));\n    }\n时间接收和忽略：接收就是自己写函数处理程序，接收后就不会自动往下传递，除非主动调用父类的处理程序，忽略就是调用父类的处理程序，父类会继续发送信号等操作\nvoid MPushButton::mousePressEvent(QMouseEvent *e)\n{\n    if(e->button()==Qt::LeftButton)\n    {\n        qDebug()<<\"按键被按下\";\n        e->ignore();//事件被忽略，时间传递给父组件，而不是父类\n        //e->accept();//接收后时间不会继续往下传递\n    }\n    else\n    {\n\n        QPushButton::mousePressEvent(e);\n    }\n\n}', 'qt');
INSERT INTO `question` VALUES ('56', 'QString 格式化', '字符串格式化：\nQString str=QString(\"<center><h1>Mouse Press: (%1, %2)</h1></center>\").arg(100).arg(\"Tom\");\n<center><h1>Mouse Press: (%1, %2)</h1></center>为设置字符串显示样式（html语句），第一个参数%1，第二个参数%2\n\nQString转char *:\nQString  str;\nchar*  ch;\nQByteArray ba = str.toLatin1(); // must\nch=ba.data();\n\nQString转int\nQString str(\"100\");\nint tmp = str.toInt();\n\nint转QString\nQString::number();', 'qt');
INSERT INTO `question` VALUES ('59', 'Qt event函数', '如果传入事件已被识别并且处理，则需要返回true,否则返回false,如果返回值是true,那么Qt会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一个事件。\n在event()函数中调用accepe()或者ignore(）函数没有作用，不会影响事件的传播。\nQEvent转换为所需要的类型，例如: QTimerEvent *evn=static_cast<QTimerEvent *>(e);\nbool event(QEvent *e)\n{\n   //事件分发e->type();\n  switch(e->type())\n  {\n    case QEvent::Close:\n     closeEvent();\n    case QEvent::MouseMove:\n     mouseMoveEvent(e); \n  }\n   \n\n}', 'qt');
INSERT INTO `question` VALUES ('60', 'eventFilter 事件过滤器', '构造函数中添加 ui->label_2->installEvent(this);//this父对象，指定有那个父对象处理,给label_2控件添加了事件过滤。\n事件过滤器和被安装的组件必须在同一个线程内，否则事件过滤器无效，Qt事件的调用最终都会追溯到virtual bool QCoreApplication::notify(QObject *receiver,QEvent *event);，该函数会将event发送给receiver,也就是调用receiver->event(event),其返回值就是来自receiver的事件处理器。\nbool eventFilter(QObject *watched, QEvent *env)\n{\n  if(watched==ui->label_2)\n  {\n    QMouseEvent *e=static_cast<QMouseEvent *>(env);\n    if(e->type()==QEvent::MouseMove)\n    {\n      \n      ui->label_2->setText(QString(\"Mouse move:(%1,%2)\")).arg(1).arg(2);\n    }\n  }\n  else\n  {\n    return QWidget::eventFilter(watched,e);\n  }\n}', 'qt');
INSERT INTO `question` VALUES ('61', '快递单', '75310856386829  内存卡 已联系  18911891016  中通快递\n13653363678  手撕素肉  \n\n  ', 'qt');
INSERT INTO `question` VALUES ('62', 'QBitMap', 'QBitMap继承于QPixMap,区别在于QPixMap主要画彩色图像，QBitMap只有黑白两种颜色。\nQPainter p(this);\np.drawPixmap(200,0,QBitmap(\"./Image/1.tif\"));\n', 'qt');
INSERT INTO `question` VALUES ('63', 'qt根目录', 'build-Image-Desktop_Qt_5_9_2_MinGW_32bit-Debug这个编译生成的程序根目录是qt程序的根目录./', 'qt');
INSERT INTO `question` VALUES ('64', 'QPixmap', '可以直接读取图片绘图\nQPainter p(this);\np.drawPixmap(0,0,QPixmap(\"./Image/1.tif\"));\n\n\nQPixmap pixmap;\npixmap.load(\"./Image/1.tif\");\npixmap.save(\"./Image/2.tif\");', 'qt');
INSERT INTO `question` VALUES ('65', '绘图设备', 'QPixmap:针对屏幕进行优化了，和平台相关。不能对图片进行修改\n\nQImage：和平台无关，可以对图片进行修改。修改像素点，在线程中绘图。\n\nQPicture：保存绘图的状态（二进制文件）。', 'qt');
INSERT INTO `question` VALUES ('66', 'paintEvent', 'void MainWindow::paintEvent(QPaintEvent *event)//重写绘图事件，如果给窗口绘图一定要在paintEvent实现\n{\n    QPainter p(this);\n    QPixmap pixmap;\n    pixmap.load(\"./Image/1.tif\");\n    p.drawPixmap(0,0,pixmap);\n\n\n}', 'qt');
INSERT INTO `question` VALUES ('67', 'QPainter', ' QPixmap  pixmap(400,300);\n QPainter p(&pixmap);//指定了绘图设备\n p.fillRect(0,0,400,300,QBrush(Qt::white));//填充白色背景\n p.drawPixmap(0,0,80,80,QPixmap(\"./Image/1.tif\"));', 'qt');
INSERT INTO `question` VALUES ('68', '算法动态库挂在到平台修改内容', '修改D:InspectionSystemRunInspectionSystemAlgConfigAlgSystemAlgSetSystemConfig.ini文件\n算法类型2名称=AOI共面度检测\n算法类型2动态库名=AlgAOICoplanCheck.dll\n算法类型2检测类型=0\n\n修改工程中 check.cpp文件CSetPROP::GetAlgorithmInfo方法中算法名称，与上述.ini文件中一致就可以。（此处名称用于界面显示，不改此处界面显示不会变）。\n\n配置文件中不要配置与BCG相关配置，否则不进入界面就会报错', 'work');
INSERT INTO `question` VALUES ('69', '获取当前时间', '1、获取带日期的时间，使用QDateTime类\nQDateTime current_date_time =QDateTime::currentDateTime();\nQString current_date =current_date_time.toString(\"yyyy.MM.dd hh:mm:ss.zzz ddd\");\ncurrent_date字符串结果为\"2016.05.20 12:17:01.445 周五\"，其中时间的显示格式可灵活配置，此处简单说明本实例中用到的部分：\nyyyy表示年；MM表示月；dd表示日； hh表示小时；mm表示分；ss表示秒；zzz表示毫秒；ddd表示周几\n详细配置格式内容较多，有需要的请自行查看Qt Assistant中关于函数QString QDateTime::toString ( const QString & format ) const的说明\n2、只需要时间，不需要日期，也可使用QTime类\nQTime current_time =QTime::currentTime();\nint hour = current_time.hour();//当前的小时\nint minute = current_time.minute();//当前的分\nint second = current_time.second();//当前的秒\nint msec = current_time.msec();//当前的毫秒\n当然QTime也可以像QDateTime::toString那样直接输出固定格式的字符串，使用方法与QDateTime::toString类似，也可参考Qt Assistant中关于函数QString QTime::toString ( const QString & format ) const的说明\n', 'qt');
INSERT INTO `question` VALUES ('70', '获取当前时间', '1）使用strftime()进行格式转换\ntime_t t = time( 0 );\nchar tmp[64];\nstrftime( tmp, sizeof(tmp), \"%Y/%m/%d %X %A 本年第%j天 %z\",localtime(&t) );\nprintf(\"%s\n\",tmp);\n输出为“2016/05/20 13:11:57 Friday 本年第141天 中国标准时间”\n其中函数size_t strftime(char *strDest,size_t maxsize,const char *format,const  struct tm *timeptr)功能为根据format指向字符串中格式命令把timeptr中保存的时间信息放在strDest指向的字符串中，最多向strDest中存放maxsize个字符。该函数返回向strDest指向的字符串中放置的字符数。\nformat说明：\n%a 星期几的简写\n%A 星期几的全称\n%b 月份的简写\n%B 月份的全称\n%c 标准的日期的时间串\n%C 年份的前两位数字\n%d 十进制表示的每月的第几天\n%D 月/天/年\n%e 在两字符域中，十进制表示的每月的第几天\n%F 年-月-日\n%g 年份的后两位数字，使用基于周的年\n%G 年份，使用基于周的年\n%h 简写的月份名\n%H 24小时制的小时\n%I 12小时制的小时\n%j 十进制表示的每年的第几天\n%m 十进制表示的月份\n%M 十时制表示的分钟数\n%n 新行符\n%p 本地的AM或PM的等价显示\n%r 12小时的时间\n%R 显示小时和分钟：hh:mm\n%S 十进制的秒数\n%t 水平制表符\n%T 显示时分秒：hh:mm:ss\n%u 每周的第几天，星期一为第一天 （值从1到7，星期一为1）\n%U 第年的第几周，把星期日作为第一天（值从0到53）\n%V 每年的第几周，使用基于周的年\n%w 十进制表示的星期几（值从0到6，星期天为0）\n%W 每年的第几周，把星期一做为第一天（值从0到53）\n%x 标准的日期串\n%X 标准的时间串\n%y 不带世纪的十进制年份（值从0到99）\n%Y 带世纪部分的十制年份\n%z，%Z 时区名称，如果不能得到时区名称则返回空字符。\n%% 百分号\n（2）使用asctime()进行格式转换\n/*得到系统时间*/\ntime_t   cur;\nstruct tm          daytime;\ncur = time((time_t*)NULL);\ntime(&cur);       \n/*时间转换*/\ndaytime = *localtime(&cur);     \nprintf(\"%s\",  asctime(&daytime));\n输出为“Wed Feb 13 15:46:11 2016”\n', 'c++');
INSERT INTO `question` VALUES ('71', '使用windows API获取当前时间', '使用Windows API 函数GetLocalTime(精确到毫秒)\nSYSTEMTIME sys;\nGetLocalTime( &sys );\nprintf(\"%4d/%2d/%2d %2d:%2d:%2d.%3d\n\",  \nsys.wYear,sys.wMonth,sys.wDay,sys.wHour,sys.wMinute,sys.wSecond,sys.wMilliseconds); \n输出为“2016/5/16 10:13:23.234”\n其中SYSTEMTIME结构体定义如下\ntypedef struct _SYSTEMTIME\n{\nWORD wYear;//年\nWORD wMonth;//月\nWORD wDayOfWeek;//星期，0为星期日，1为星期一，2为星期二……\nWORD wDay;//日\nWORD wHour;//时\nWORD wMinute;//分\nWORD wSecond;//秒\nWORD wMilliseconds;//毫秒\n}SYSTEMTIME,*PSYSTEMTIME;\n', 'c++');
INSERT INTO `question` VALUES ('72', 'QLineEdit ', 'QIntValidator v( 0, 100, this );    \n QLineEdit* edit = new QLineEdit( this );     // 这个行编辑只接受从0到100的整数     \nedit->setValidator( &v );', 'qt');
INSERT INTO `question` VALUES ('73', 'Qt样式表', 'QWidget::setStyleSheet()设计样式表\nui->label->setStyleSheet(\"QLabel{color:red;}\");\nui->label->setStyleSheet(\"QLabel{color:rgb(0,255,255);\"//字体\n                             \"background-color:black\"//背景\n                             \"}\");\nthis->setStyleSheet(\"QLabel{color:red;}\");//this内所有QLabel都是红色字体，但是可以具体QLabel更改\n\"background-image:url(:/new/prefix1/start.jpg)\"添加背景图，图像会平铺，不会自动缩放大小\n\"border-image:url(:/new/prefix1/start.jpg)\"       添加背景图，图像不会平铺，自动缩放大小\nQPushButton:hover{border: 2px outset green}  伪状态：(:hover)\nline-height : 150%  行高\nfont-size : 8pt;    字体大小\nfont-family:SimHei; 字体类型\nfont-weight: bold;  加粗\ncolor:blue;         字体颜色', 'qt');
INSERT INTO `question` VALUES ('74', '查看已连接无线网密码', '右键无线网图标-》网络和共享中心-》查看网络活动里单击无线网文字-》无线属性-》安全-》显示字符', 'windows');
INSERT INTO `question` VALUES ('75', '目标跟踪与定位1', 'Haris-Shi-Tomasi角点检测器（哈尔角点检测）\ncv::GFTTDetector::public cv::Featrue2D。\n参数（int maxCorners(检测的最大角点数量),\n      double qualityLevel (认定为是一个角点的最小低阶特征值，一般设置为0.1或0.01),\n      double minDistance(默认为1),\n      int blockSize(计算导数的自相关矩阵时对应像素所在区域，默认为3),\n      bool useHarrisDetector(是否用哈儿检测),\n      double k(权重系数，默认0.04) ）', 'opencv');
INSERT INTO `question` VALUES ('76', 'Python和Spyder的安装', '下载地址：https://www.python.org/downloads/\nPip的安装：\n1.下载：https://pypi.org/project/pip/#files\n2.在文件目录下，输入：python setup.py install ，安装pip安装完成后在Scripts目录下。环境变量配置pip\n\n\nSpyder:  pip install spyder\n\n', 'Python');
INSERT INTO `question` VALUES ('77', 'Windows+Ubuntu双系统设置Windows为第一启动项', '在安装双系统的时候，如果先安装的是Windows然后再安装Ubuntu系统，开机时是以Ubuntu的grub来引导Windows的，而且默认进入Ubuntu系统。\n\n修改grub\n输入命令：sudo vim /etc/default/grub\n现在进入grub文件中，找到GRUB_DEFAULT=0，为0表示Ubuntu为第一个启动。现在主要是修改这个值来使Windows为第一启动项。\n在开机时会有选项让你选择进入哪个系统，默认是Ubuntu，则GRUB_DEFAULT=0，若第三个为Windows，则GRUB_DEFAULT=2。所以更改grub文件中的GRUB_DEFAULT的值，即可设置Windows为第一启动项。\n输入命令：sudo update-grub更新grub文件即可。\n\n首先打开grub的配置文件。sudo  gedit    /boot/grub/grub.cfg\n在配置文件中找到我们的win7引导菜单选项。\n复制win7引导菜单名称，例如这里的 Windows7 (loader) (on /dev/sdb1)。\n接着编辑etc下的grub文件。sudo  gedit   /etc/default/grub把里面的GRUB_DEFAULT设置为我们复制的win7引导菜单名称。\n接着我们更新grub菜单。sudo update-grub\n接着重启ubuntu系统，开机的时候就会默认选择win7系统进入。', 'Ubuntu');
INSERT INTO `question` VALUES ('78', '有线网络连接', '设置-》network里设置网络ip 网关等。\n\nsudo nano /etc/network/interfaces', 'Ubuntu');
INSERT INTO `question` VALUES ('79', '查看安装路径', 'which python3', 'Ubuntu');
INSERT INTO `question` VALUES ('80', '更换阿里源', 'sudo gedit /etc/apt/sources.list\n\n# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted\ndeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties\ndeb http://archive.canonical.com/ubuntu xenial partner\ndeb-src http://archive.canonical.com/ubuntu xenial partner\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted\ndeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security universe\ndeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse\n\nsudo apt-get update', 'Ubuntu');
INSERT INTO `question` VALUES ('81', 'deb文件的安装', 'sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb', 'Ubuntu');
INSERT INTO `question` VALUES ('82', '查看软件版本', 'pkg-config --modversion opencv', 'Ubuntu');
INSERT INTO `question` VALUES ('83', '搜狗输入法安装', '先安装搜狗输入法软件sudo dpkg -i install sogou*.deb\n打开终端运行命令：im-config后，点击OK，看到fcitx的窗口选择fcitx其余全部yes或者ok. 然后重启ubuntu。\nim-config找不到fcitx；\nsudo apt-get --fix-broken install 运行这条命令需要联网，可以考虑先更新阿里源\n在fcitxconfigure点击加号添加搜狗输入法。', 'Ubuntu');
INSERT INTO `question` VALUES ('84', '文件解压', 'tar.bz2文件 tar jxvf boost_1_56_0.tar.bz2\ntar -jxvf xx.tar.bz2 -C /xx/xxx/xxx   -C大写，后面接要解压的路径\n\nunzip *.zip', 'Ubuntu');
INSERT INTO `question` VALUES ('85', 'nvidia 驱动、cuda和cudnn的安装', '运行nvidia_driver.sh cuda.sh 两个脚本\n先解压cudnn-9.0-linux-x64-v7.1.tgz\n再运行cudnn.sh，此处只是文件的复制。\nnvidia-smi   \nnvidia-settings \nubuntu-drivers devices 检查硬件信息\nubuntu-drivers autoinstall 自动安装驱动', 'Ubuntu');
INSERT INTO `question` VALUES ('86', '查看cpu进程数量', 'top命令', 'Ubuntu');
INSERT INTO `question` VALUES ('87', 'Anaconda 安装', 'Ubuntu:\n到国内清华镜像https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/ \nanaconda -v查看版本信息\n\n或者官网 https://repo.continuum.io/archive/', 'Python');
INSERT INTO `question` VALUES ('88', 'python版本', '# 第2种方法\nimport sys \nprint(sys.version)\nprint(sys.version_info)', 'Python');
INSERT INTO `question` VALUES ('89', 'anaconda更改下载源', '命令行中运行以下代码即可添加 Anaconda Python 免费仓库：\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --set show_channel_urls yes\n执行完上述命令后会在当前用户目录下生成.condarc文件\n确认.condarc文件内容 （在用户目录下，比如C:Users用户名.condarc）\nchannels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  \n  - defaults\nshow_channel_urls: true\n确认无误后，关闭控制台窗口，重新打开才会重新加载配置。（不确定是否正确，感觉不需要重新打开控制台窗口也可以）\n大部分网站上的说法都是如上。不过我做完如上更改，更新spyder的时候依旧使用的是官网的源，最后更新失败。\n最后发现把.condarc文件中的 - defaults那行去掉，就不会出现这个问题了。理论上直接建立.condarc文件，修改里面的内容，也可以实现同样的功能。我最终把其他的目录也加上了，最终的.condarc文件如下所示：\nchannels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  \n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/mro\nshow_channel_urls: true\nconda info查看', 'Python');
INSERT INTO `question` VALUES ('90', 'anaconda查找安装包版本并指定channel安装', '查看安装包的所有可用版本和channel\nanaconda search -t conda skimage \n根据包名查找安装包channel\nanaconda show  DavidMertz/accelerate-skimage\n根据提示，我们使用下面的指令install这个包\nconda install --channel https://conda.anaconda.org/DavidMertz accelerate-skimage', 'Python');
INSERT INTO `question` VALUES ('91', 'spyder快捷键设置', 'Tools->Preferences->Keyboard shortcuts', 'Python');
INSERT INTO `question` VALUES ('92', 'spyder启动程序传入参数', 'Run ->Configure->  command line options', 'Python');
INSERT INTO `question` VALUES ('93', '安装包下载地址', 'https://www.lfd.uci.edu/~gohlke/pythonlibs/', 'Python');
